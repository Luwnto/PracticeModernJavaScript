# ES6 概要

ES6在语法层面带来了很大的非破坏性更新，我们将在本章中讨论其中的大多数内容。这些改变大多为语法糖，这意味着，这些新语法其实用ES5，也是可以写出来了，只是可能会更复杂一些。新增的变量声明方式 `let` 和 `const` 则不仅仅是语法糖，我们会在本章最后讨论一下这个。

ES6中的对象字面量有一些小的语法更新，我们从此处开始讨论。

## 对象字面量

对象字面量是指以`{}`形式什么的对象，比如下面这样：

```js
var book = {
  title: 'Modular ES6',
  author: 'Nicolas',
  publisher: 'O´Reilly'
}
```

ES6 对对象字面量语法带来了一些改进：包括，属性/方法的简洁表示，可计算的属性名等等，我们逐一来看：

### 属性的简洁表示法

有时候，我们声明的属性名中有几个他们的值所对应的变量和属性名是一致的。比如说我们有个名为`listeners` 的数组，当我们想把它赋值给对象中属性名为 `listeners` 的对象字面量时，我们需要重复写这个名字。如下所示

```js
var listeners = []
function listen() {}
var events = {
  listeners: listeners,
  listen: listen
}
```

如果你也用到过这种情况，你就利用ES6语法的新特性简写成下面这种形式了：

```js
var listeners = []
function listen() {}
var events = { listeners, listen }
```

之后我们还会讨论到，合理去重能帮助在不影响语义的情况下减少重复代码。在下面的代码片段中，我重写了浏览器的永久存储`api`，`localStroge`,作为常驻内存的`ployfill`,如果不用简写，它将显得很冗长：

```js
var store = {}
var storage = { getItem,  setItem, clear }
function getItem(key) {
  return key in store ? store[key] : null
}
function setItem(key, value) {
  store[key] = value
}
function clear() {
  store = {}
}
```

这是众多ES6中的意在减少你的代码复杂度的语法之一，一旦你习惯使用这种语法，你会发现无论是代码的可读性还是你自己的开发效率都会得以提升。

### 可计算的属性名

有时候你声明的对象中会包含一些属性名是依据JS的变量或者其它一些表达式生成，如下用ES5所写的代码所示。在这个例子中，你可以把`expertise`假设为一个你事先并不知道的函数参数：

```js
var expertise = 'journalism'
var person = {
  name: 'Sharon',
  age: 27
}
person[expertise] = {
  years: 5,
  interests: ['international', 'politics', 'internet']
}
```

ES6 中的对象字面量并不限制你只能使用静态属性名，通过可计算属性名，你可以把任何表达式放在中括号中，把它们的值当做属性名，下面的代码表示了上述ES5代码的ES6写法，看看是不是简介了许多：

```js
var expertise = 'journalism'
var person = {
  name: 'Sharon',
  age: 27,
  [expertise]: {
    years: 5,
    interests: ['international', 'politics', 'internet']
  }
}
```

不过属性你不能同时使用简写属性和属性名计算，简写属性是一种在编译阶段的用以减少重复的语法糖，而计算属性名会在运行时生效。考虑到这两种不相容的特性，以下代码会报错。在大多数情况下，二者结合使用会导致代码难易阅读，所以二者不能一起使用也许也是一个好事。

```js
var expertise = 'journalism'
var journalism = {
  years: 5,
  interests: ['international', 'politics', 'internet']
}
var person = {
  name: 'Sharon',
  age: 27,
  [expertise] // 这里会报语法错误
}
```

计算属性名的一个常用场景发生在当我们想把一个对象的某个属性添加为另外一个对象的属性，如下所示，除了使用第三方声明，我们可以采用如下简写形式：

```js
var grocery = {
  id: 'bananas',
  name: 'Bananas',
  units: 6,
  price: 10,
  currency: 'USD'
}
var groceries = {
  [grocery.id]: grocery
}
```

另一个例子是我们接受函数的参数用以构建对象。在ES5代码中，我们需要声明一个对象字面量并分配一个属性，然后动态的添加属性，然后反对这个对象。下述代码表明了这个过程，我们创建一个包裹函数可以在之后用以响应Ajax请求，当出错时返回的对象将拥有一个`error`属性及对应的描述，当执行正确时，将由一个`success`属性及对应的描述。

```js
function getEnvelope(type, description) {
  var envelope = {
    data: {}
  }
  envelope[type] = description
  return envelope
}
```

利用计算属性，我们可以更加简明的实现一样的效果：

```js
// es6
function getEnvelope(type, description) {
  return {
    data: {},
    [type]: description
  }
}
```

关于对象字面量的最后一个改进是关于函数的

### 方法定义

一般说来，你可以像添加属性一样添加函数。在下面的代码示例中，我们会创建一个小的事件发生器，它拥有一个`emitter#on`方法可以用以注册事件，还有一个`emitter#emit`方法可用以执行事件

```js
var emitter = {
  events: {},
  on: function (type, fn) {
    if (this.events[type] === undefined) {
      this.events[type] = []
    }
    this.events[type].push(fn)
  },
  emit: function (type, event) {
    if (this.events[type] === undefined) {
      return
    }
    this.events[type].forEach(function (fn) {
      fn(event)
    })
  }
}
```


在ES6中你可以使用新的语法来定义对象中的函数了，我们可以省略`function`关键字和毛航了。如下所示，用ES6 的新语法，我们的方法声明更加简洁了

```js
var emitter = {
  events: {},
  on(type, fn) {
    if (this.events[type] === undefined) {
      this.events[type] = []
    }
    this.events[type].push(fn)
  },
  emit(type, event) {
    if (this.events[type] === undefined) {
      return
    }
    this.events[type].forEach(function (fn) {
      fn(event)
    })
  }
}
```

箭头函数是ES6中声明函数的另外一种语法，它还有一些特别的优点，我们一起来看看箭头函数是什么，它该如何声明，看看在语义上它又有何不同。

## 箭头函数

传统上，在JS中，函数的声明包括函数名，一系列参数和函数体，如下所示：

```js
function name(parameters) {
  // function body
}
```

同样，也支持声明匿名函数，即不给函数命名而是把函数赋值给一个变量，属性或者直接调用函数：

```js
var example = function (parameters) {
  // function body
}
```

从ES6 开始，你可以使用箭头函数来写匿名函数了。不过要记住，这和传统的匿名函数有一些不同的地方，下例中的匿名函数看起来其实和上面我们用ES5语法写的匿名函数很想，唯一的不同在于确实`function`关键字，参数和函数体之间以`=>`相连接。

```js
var example = (parameters) => {
  // function body
}
```

尽管箭头函数看起来很像典型的匿名函数，但是他们却具有根本性的不同：箭头函数不能被直接命名，尽管允许把它们赋值给一个变量，它们不能被用做构造函数，它们也没有`prototype`属性，这意味着你不能对箭头函数使用`new`关键字，并且他们还绑定了词法作用域，这意味着他们不会修改`this`的指向。

接下来我们深入解释一下和传统函数相比二者的语义上的区别。

### 词法作用域

在箭头函数的函数体内，`this`,`arguments`,`super`都指向包含箭头函数的作用域，箭头函数本身不产生新的作用域。以如下代码为例，这里有一个名为`timer`的对象，属性`seconds`用以计数，`start`方法用以开始计时，当我们在若干秒后调用`start`方法时，将打印出当前的`seconds`值。

```js
var timer = {
  seconds: 0,
  start() {
    setInterval(() => {
      this.seconds++
    }, 1000)
  }
}
timer.start()
setTimeout(function () {
  console.log(timer.seconds)
}, 3500)
// <- 3
```

如果这里我们没用箭头函数而用的是常规的匿名函数，`this`将指向匿名函数本身，在`start`方法开头处，我们也需要使用`var self = this`这样的语法，然后在之后的匿名函数中使用`self`代替`this`，使用箭头函数，我们无需再做这些多余的操作来标注上下文一致，而可以专注于函数本身的代码了。

类似的，ES6中的箭头函数的作用域绑定意味着函数调用不能通过`.call`,`.apply`,`.bind`等改变函数的作用域。这种限制利大于害，它保证了上下文永远保持不变。

我们再来看看下面这个例子，你猜猜，最终打印出的结果是什么：


```js
function puzzle() {
  return function () {
    console.log(arguments)
  }
}
puzzle('a', 'b', 'c')(1, 2, 3)
```

答案是，对常规匿名函数而言，`arguments`指向匿名函数本身，所以此处打印的结果会是1,2,3

作为对比，我们看看下面这个例子，在本例中，箭头函数的作用域指向`puzzle`函数，这次的打印结果会是`a,b,c`,箭头函数的中调用`arguments`其实是`puzzle`函数的`arguments`

前面我们提到过，箭头函数有几种表达形式，但是现在我们看到的例子中，都是完整的箭头函数形式，下面我们看看，箭头函数的其它写法。

### 箭头函数的不同写法

一直以来我们的箭头函数是这样写的：

```js
var example = (parameters) => {
  // function body
}
```

变种之一是，当只有一个参数时，我们可以省略箭头函数参数中的括号，这样减少了括号的数量，当箭头函数是另外一个函数的方法时，这样对一些人来说是更容易阅读的。

```js
var double = value => {
  return value * 2
}
```

实践说明，对简单函数来说，箭头函数是常用的（类似上述`double`函数所示），接下来的形式更加简洁，这次我们去除了表征函数体的`{}`，直接写上`value * 2`这样的语句，当这个函数被调用时，这个语句将被调用，并把结果当做返回值返回。`return` 是静默发生的，这里不再需要花括号，不过只能使用单一表达式。

```js
var double = (value) => value * 2
```

这里也可以结合上面说的两种简写，而得到更加简洁的形式

```js
var double = value => value * 2
```

现在，你对箭头函数有了一定的理解，下面我们结合它的优点，并说明它们在何时会非常有用。

### 箭头函数的优点和使用示例

不过事先得声明一点，我们并不应该盲目的在一切地方采用`ES6`,是否使用新语法的原则是看采用了新语法能否在实质上改善代码的可读性和可维护性。ES6并没有在任何地方比我们一直写的ES5好，过渡对待ES6 并不好。

在一些情况下，箭头函数可能并非最好的工具，比如说，你有一个包含若干行代码的复杂函数，使用`=>`代替`function`关键字可能很难改善你的代码。箭头函数用在简单的代码时是有效的，`function`关键字及相应的语法标准是组成函数表达式的重要部分。

合理的命名和添加作用域能让函数更利于阅读和看明白，箭头函数并不能直接命名，但是却可以通过复制给变量的形式实现间接命名，比如如下代码中，我们把箭头函数赋值给变量 `throwError`，当函数被调用时，值是一段错误，通过追溯我们可以找到报错的箭头函数是`throwError`.

```js
var throwError = message => {
  throw new Error(message)
}
throwError('this is a warning')
<- Uncaught Error: this is a warning
  at throwError
```


当所定义的函数需要采用和外部一样的作用域时，箭头函数是简洁且有效的，这类的定义使得你的函数在一些情况下很简洁，这在某些函数式编程的情况下非常有效，比如我们使用`.map`,`.filter`,`.reduce`时。如下所示

```js
[1, 2, 3, 4]
  .map(value => value * 2)
  .filter(value => value > 2)
  .forEach(value => console.log(value))
// <- 4
// <- 6
// <- 8
```

### 箭头函数省写形式返回对象字面量的一些问题

当你想以简洁的形式返回一个对象时，你需要用小括号括起来你想返回的对象。否则，浏览器会把对象的`{}`解析为箭头函数的开始和结束，把里面的内容解析为函数体。

```js
// 正确的使用形式
var objectFactory = () => ({ modular: 'es6' })
```

在下面这个错误示例中，箭头函数把花括号解析为函数体，`number`被解析为`label`,`value`表达式并没有做任何事情，由于我们现在有了函数体，有没有做任何返回值，下述代码的结果就会是`undefined`了。

```js
[1, 2, 3].map(value => { number: value })
// <- [undefined, undefined, undefined]
```

当我们返回的对象字面量不止一个值的时候，浏览器编译器不能正确解析第二个参数，因此会抛出语法错误。

```js
[1, 2, 3].map(value => { number: value, verified: true })
// <- SyntaxError
```

把返回的对象字面量包裹在小括号中能解决这个问题，这样浏览器就可以正确的解析了：

```js
[1, 2, 3].map(value => ({ number: value, verified: true }))
/* <- [
  { number: 1, verified: true },
  { number: 2, verified: true },
  { number: 3, verified: true }]
*/
```

## 分配解构

解构是ES6提供的最灵活和富于表现的特性了。也是最简单的特性之一，它可以按你所需绑定多个变量，并可应用于对象，数组甚至函数参数。我们一个个的来看，先从对象说起吧。

### 对象解构

设想你有一个程序，这个程序中包含一些漫画人物，Bruce Wayne 就是其中之一，现在你想引用描述它的对象中的一个属性，可能你会按下面说的这样做。

```js
// 描述Bruce Wayne的对象
var character = {
  name: 'Bruce',
  pseudonym: 'Batman',
  metadata: {
    age: 34,
    gender: 'male'
  },
  batarang: ['gas pellet', 'bat-mobile control', 'bat-cuffs']
}
```

如果你想把一个名为`pseudonym` 的对象指向`character.pseudonym`,你可以写下面这样的ES5代码，这在你想在程序中多次引用这个属性而又不想多敲字符时是很常见的。

```js
var pseudonym = character.pseudonym
```

通过结构赋值，语法能看起来更清晰。如下所示，你不再需要写两次`pseudonym`了

```js
var { pseudonym } = character
```

如同你可以使用`var`加逗号在同时声明多个变量一样，你同样可以在花括号内通过解构声明多个变量。

```js
var { pseudonym, name } = character
```

类似的，你可以混合使用解构和常规的自定义变量，尽管这样写初看起来让人觉得疑惑，但是是否使用还是取决于你所遵循的代码风格中对变量定义的描述。不过，无论怎么说来，解构语法确实表现出了其灵活性。

```js
var { pseudonym } = character, two = 2
```

比如说你现在有这样的需求，你想提取出`pseudonym`属性，但是想要把它赋值给变量 `alias`,你可以按照如下方法使用解构，赋予该值以别名（`aliasing`），这里我们取的别名为`alias`,当然你可以取任何你想取的名字。

```js
var { pseudonym: alias } = character
console.log(alias)
// <- 'Batman'
```

上述代码初看起来可能也没有用ES5语法时那么简洁，但是如果当你把解构用于多层结构时就能体会到它带来的好处了，看下面这个例子。

```js
var { metadata: { gender } } = character
```

当然，多层解构也是可以赋予别名的，这样可以方便的更改子层属性的名称：

```js
var { metadata: { gender: characterGender } } = character
```

上面描述的场景是很常见的，因为属性值常常位于宿主对象中，尽管`palette.color.code`也具有较好的描述性，`code`这个词可以指代的意义有点太广了，使用别名`colorCode`可以帮助你结合上下文有一个语义更好的值。

在ES5 中，当你调用一个未曾声明的值时，你会得到`undefined`:

```js
console.log(character.boots)
// <- undefined
console.log(character['boots'])
// <- undefined
```

使用解构，情况也是类似的，当你声明了一个不存在属性的解构变量，你也会得到`undefined`.

```js
var { boots } = character
console.log(boots)
// <- undefined
```

深层的结构不存在的值（`null`或`undefined`）时，程序会抛出异常，这一点和你试图调用`null`或`undefined`的属性值时表现是一样的。

```js
var { boots: { size } } = character
// <- Exception
var { missing } = null
// <- Exception
```

解构其实就是语法糖，如果转换为下面这样的语法，你肯定就能很清楚的明白为什么会抛出异常了。

```js
var nothing = null
var missing = nothing.missing
// <- Exception
```

回到解构，当属性值为`undefined`时，你可以给属性值添加默认值，属性值可以是数值，字符串，函数，对象，甚至指向其它变量：

```js
var { boots = { size: 10 } } = character
console.log(boots)
// <- { size: 10 }
```

对于嵌套解构，同样可以赋予默认值

```js
var { metadata: { enemy = 'Satan' } } = character
console.log(enemy)
// <- 'Satan'
```

默认值和别名也可以一起使用，需要注意的是你需要把别名放在前面，默认值放在后面：

```js
var { boots: footwear = { size: 10 } } = character
```

解构语法同样支持计算属性名，不过要这样使用，你需要用别名，这是因为计算属性名允许任何类似的表达式，这样会导致编译器无法识别变量名，看下面这个示例：

```js
var { ['boo' + 'ts']: characterBoots } = character
console.log(characterBoots)
// <- true
```

解构有时候作用也没那么大，连续语句`characterBoots = character[type]`通常看起来比`{ [type]: characterBoots } = character`更简单，这意味着在当你想要以对象字面量的形式声明属性时，对象解构才是有优势的。

这就是在对象中使用解构的方法了，下面看看在数组中该如何使用。

### 数组解构

数组解构的语法和对象解构是类似的。下例中`coordinates`对象被解构为两个变量 `x,y`.值得注意的是，这里我们用的是中括号而非花括号，这表明这里是数组解构而非对象解构。通过数组解构你不需要使用`x = coordinates[0]`这样的语法了，通过解构不使用索引值，你也可以清楚的表达明白你的意思。

```js
var coordinates = [12, -7]
var [x, y] = coordinates
console.log(x)
// <- 12
```

数组解构也允许你跳过你不想用到的值：

```js
var names = ['James', 'L.', 'Howlett']
var [ firstName, , lastName ] = names
console.log(lastName)
// <- 'Howlett'
```

和对象解构一样，数组解构也允许你使用默认值：

```js
var names = ['James', 'L.']
var [ firstName = 'John', , lastName = 'Doe' ] = names
console.log(lastName)
// <- 'Doe'
```

在ES5中，你想交换两个变量的值通常要用到第三个变量，如下所示：

```js
var left = 5
var right = 7
var aux = left
left = right
right = aux
```

使用解构，可以避免使用第三个变量`aux`,而是你专注于你的意图，

```js
var left = 5
var right = 7
[left, right] = [right, left]
```

关于解构，我们想要聊的最后一方面是关于函数的

### 函数默认参数

ES6中的函数也享受到了分配默认值带来的好处，下例中我们就给参数 `exponent`分配了一个默认值：

```js
function powerOf(base, exponent = 2) {
  return Math.pow(base, exponent)
}
```

箭头函数同样支持使用默认值，需要注意的是，就算只有一个参数，如果要赋予默认值，我们还是需要用小括号括起参数部分。

```js
var double = (input = 0) => input * 2
```

就像和一些其它语言一样，默认值不仅仅限于最右面的参数。你可以给任何位置的任何参数提供默认值。

```js
function sumOf(a = 1, b = 2, c = 3) {
  return a + b + c
}
console.log(sumOf(undefined, undefined, 4))
// <- 1 + 2 + 4 = 7
```

在JS中，给一个函数提供一个包含若干属性的对象字面量做为参数并不常见，不过你可以按下面这样的方式使用：

```js
var defaultOptions = { brand: 'Volkswagen', make: 1999 }
function carFactory(options = defaultOptions) {
  console.log(options.brand)
  console.log(options.make)
}
carFactory()
// <- 'Volkswagen'
// <- 1999
```

不过这样也要一定的问题，就是如果你调用函数时传入的参数只包含一个属性，另一个属性的默认值会丢失：

```js
carFactory({ make: 2000 })
// <- undefined
// <- 2000
```

通过混合使用解构和函数默认值，我们可以解决这个问题。

### 函数参数解构

一个比仅提供默认值更好的办法是完全解构`options`,为每一个属性提供默认值。解构模式还允许你不使用`options`对象而单独使用每一个值，不过这样你也失去了直接使用`options`对象的能力。这在某些情况下可能也会导致问题。

```js
function carFactory({ brand = 'Volkswagen', make = 1999 }) {
  console.log(brand)
  console.log(make)
}
carFactory({ make: 2000 })
// <- 'Volkswagen'
// <- 2000
```

在这种情况下，用户如果没有提供`options`对象，我们将又丢失默认值。这意味着如果没有提供`options`,`carFactory()`函数将抛出异常。这种问题可以通过下面这种语法来修复，这种语法添加了一个空数组作为`options`的默认值，这样在调用的时候如果参数为空，就会把空对象当做默认参数了，这样也能利用每一个默认的属性值。

```js
function carFactory({
  brand = 'Volkswagen',
  make = 1999
} = {}) {
  console.log(brand)
  console.log(make)
}
carFactory()
// <- 'Volkswagen'
// <- 1999
```

除了默认值，你还可以在函数中使用解构来描述你的函数能够处理的对象，考虑下面的代码片段，这里我们有一个名为`car`的对象，这个对象拥有很多属性。`car`对象，描述了它的所有者，品牌，生产者，何时生产，以及所有者选择的参数。

```js
var car = {
  owner: {
    id: 'e2c3503a4181968c',
    name: 'Donald Draper'
  },
  brand: 'Peugeot',
  make: 2015,
  model: '208',
  preferences: {
    airbags: true,
    airconditioning: false,
    color: 'red'
  }
}
```

如果我们想函数只处理这里面的部分属性，使用解构是个好办法。好处是，在读取函数的签名时，我们会意识到所需的所有属性。当我们完全使用解构时，很容易指出，何时输入会不满足函数的合同。下面的示例演示如何在参数列表中指定所需的每个属性，我们用`getCarProductModel` API来展示如何使用：

```js
var getCarProductModel = ({ brand, make, model }) => ({
  sku: brand + ':' + make + ':' + model,
  brand,
  make,
  model
})
getCarProductModel(car)
```

除了使用`options`对象填充，下面我们看看，解构还有什么好的用途。

> 可以只利用一个对象中的部分参数，其实参数的解构通过把函数参数当做一个对象就可以比较容易的理解了。

### 解构使用示例

当一个函数想要返回数组或者对象时，使用解构能让转换显得更加简洁。下例中，函数`getCoordinates()`返回了一系列的值，但是我们只取用其中的一部分值`x,y`。这样我们避免了很多中间变量的使用，同样使得代码更具可读性。

```js
function getCoordinates() {
  return { x: 10, y: 22, z: -1, type: '3d' }
}
var { x, y } = getCoordinates()
```

通过使用默认值，可以减少重复，比如你想写一个`random`函数，这个函数用以返回一个位于`min`和`max`之间的值。默认在1到10之间。这在如Python、C# 这类具有强类型特征的语言中作为命名参数的替代品特别有意思。这种模式允许为参数定义默认值并只覆盖部分值，这提供了极大的灵活性：

```js
function random({ min = 1, max = 10 } = {}) {
  return Math.floor(Math.random() * (max - min)) + min
}
console.log(random())
// <- 7
console.log(random({ max: 24 }))
// <- 18
```

正则表达式也非常适用于解构，解构允许你不用重新制定索引值就给一种匹配重命名。下面是一个`RegExp`的例子，这个例子允许你解析一些数据。这是一个允许你解析你的数据到它们各自组件的例子。结果数组中的第一个被保留为原生输入，这里我们可以舍弃它。（正则返回的是一个数组）

```js
function splitDate(date) {
  var rdate = /(\d+).(\d+).(\d+)/
  return rdate.exec(date)
}
var [ , year, month, day] = splitDate('2015-11-06')
```

当你的正则表达式不匹配时就需要小心了，这时候会返回`null`,为可能的失败提供测试是一种好的实践，如下代码所示：

```js
var matches = splitDate('2015-11-06')
if (matches === null) {
  return
}
var [, year, month, day] = matches
```

下面我们继续来讲讲`spread`和`rest`操作符。


## 剩余参数和拓展符

ES6之前，和任意数量的函数参数进行交互是很复杂的。你需要使用`arguments`,这是一个伪数组，拥有`length`属性。通常你需要通过`Array#slice.call`转换`arguments`对象为真实的数组后再进行操作,如下所示：

```js
function join() {
  var list = Array.prototype.slice.call(arguments)
  return list.join(', ')
}
join('first', 'second', 'third')
// <- 'first, second, third'
```

对这种情况，ES6提供了一种更好的解决方案，这就是`rest`.

### 剩余参数`rest`

现在通过在任意JavaScript函数中的最后一个参数前添加三个点`...`，把它转换为特殊的`rest`参数。当`rest`参数是函数的唯一参数时，它就代表了传递给这个函数的所有参数。它和前面说到的`.slice`可以起到一样的作用，但是你可以避免使用类似`arguments`这样复杂的构造了，并且在参数列表中就可以直接指定了。

```js
function join(...list) {
  return list.join(', ')
}
join('first', 'second', 'third')
// <- 'first, second, third'
```

`rest`参数之前的命名参数不会被包含在`rest`参数中，

```js
function join(separator, ...list) {
  return list.join(separator)
}
join('; ', 'first', 'second', 'third')
// <- 'first; second; third'
```

不过需要注意的是，在箭头函数中使用`rest`参数时，即使只有这一个参数，也需要使用圆括号把它围起来，不然就会报错`SyntaxError`，下面是一个结合使用二者的例子：

```js
var sumAll = (...numbers) => numbers.reduce(
  (total, next) => total + next
)
console.log(sumAll(1, 2, 5))
// <- 8
```

对比具有相同功能的ES5代码，这样更加复杂但是却更紧凑了。`sumAll`函数对不熟悉使用`.reduce`方法的读者来说可能更具有迷惑性，同样由于使用了两重的箭头函数也是的复杂性增加。这需要我们有所权衡，关于这一点，我们会在本书的第二部分讲述。

```js
// ES5的写法
function sumAll() {
  var numbers = Array.prototype.slice.call(arguments)
  return numbers.reduce(function (total, next) {
    return total + next
  })
}
console.log(sumAll(1, 2, 5))
// <- 8
```

### 拓展运算符

拓展运算符可以把任意可枚举对象转换为数组，拓展可以高效对拓展目标对象如数组字面量或函数调用进行操作。下例中使用`...arguments`转换了一个函数的参数为数组字面量。

```js
function cast() {
  return [...arguments]
}
cast('a', 'b', 'c')
// <- ['a', 'b', 'c']
```

使用拓展运算符，我们还可以很方便的把一段字符串转换为由每一个字母组成的数组：

```js
[...'show me']
// <- ['s', 'h', 'o', 'w', ' ', 'm', 'e']
```

你还可以在拓展运算符左右添加其他参数，已获得你想要的结构:

```js
function cast() {
  return ['left', ...arguments, 'right']
}
cast('a', 'b', 'c')
// <- ['left', 'a', 'b', 'c', 'right']
```

在合并多个数组时，拓展运算符也是非常有用的，下例展示了如何使用拓展拼合多个数组为一个数组字面量：

```js
var all = [1, ...[2, 3], 4, ...[5], 6, 7]
console.log(all)
// <- [1, 2, 3, 4, 5, 6, 7]
```

值得注意的是，拓展运算符不仅仅可以运用于数组和`arguments`对象，它对任意可迭代的对象都可以使用。迭代也是ES6新提出的一个概念，它允许你转换任意对象为可迭代的。在[ Iteration and Flow Control]()这一章，我们将详细叙述这个概念。


#### Shifting和Spreading
> 拓展知识

当你想要抽出一个数组的前一个或者两个元素时，常用的解决方案是使用`.shift`.尽管是函数式的，下述代码在第一次看到的时候却不好理解，因为我们使用了两次`.slice`从`list`中抽离出两个不同的元素。重点是，像很多ES6之前的解决方案，我们应该让语言来解决我们遇到的这些问题。

```js
var list = ['a', 'b', 'c', 'd', 'e']
var first = list.shift()
var second = list.shift()
console.log(first)
// <- 'a'
```

在ES6中，你可以结合使用拓展和解构，下面的代码和上述代码具有一样的功能，不过只用一行代码就解决了上述的问题，二者这一行代码比之前使用`list.slice()`更具有可读性：

```js
var [first, second, ...other] = ['a', 'b', 'c', 'd', 'e']
console.log(other)
// <- ['c', 'd', 'e']
```

使用拓展运算符，你可以专注于实现你需要的功能，让语言做别的事情。在提高表述性和描述性的同时降低语言的限制在ES6中很常见。

在ES6之前，当你需要一个动态的参数列表，并应用到某个函数调用时，你需要使用`.apply`。这其实是不雅的，因为这设计到改变`this`的上下文，你在这时候很容易疏忽。

```js
fn.apply(null, ['a', 'b', 'c'])
```

除了对数组进行拓展，你同样可以对函数调用进行拓展，下例展示了如何添加任意数量的参数到`multiply`函数中。

```js
function multiply(left, right) {
  return left * right
}
var result = multiply(...[2, 3])
console.log(result)
// <- 6
```

想在数组中一样，对函数参数使用拓展运算符可以结合常规的参数一起使用。下例中，`print`函数结合使用了`rest`,普通参数，和拓展,这的确让我们的代码更加简洁又不至于稀释：

```js
function print(...list) {
  console.log(list)
}
print(1, ...[2, 3], 4, ...[5])
// <- [1, 2, 3, 4, 5]
```

使用`.apply`的另外一个限制是，当使用关键字`new`实例化一个对象时，会非常啰嗦。下面是一个结合`new`,`apply`来创建一个`Date`对象的示例，如果不考虑JS中的月份是从0开始计算的，11会被解析为十二月份，只是为了创建一个Date实例，下面这样的语句真的显得太麻烦了：

```js
new (Date.bind.apply(Date, [null, 2015, 11, 31]))
// <- Thu Dec 31 2015
```

再看下面这段代码，拓展运算符去除了一切冗余的东西，只剩下重要的东西，只使用`new`创建新实例，使用`...`创建了一个动态的数组，然后调用Date函数，这就足够了：

```js
// 关于解构是如何绑定的this,语法糖是如何工作的，还是存在一些不太明白的地方
new Date(...[2015, 11, 31])
// <- Thu Dec 31 2015
```

下表总结了，我们是如何使用拓展运算符的：

| 使用示例 | ES5 | ES6 |
| --- | --- | --- |
| Concatenation | `[1, 2].concat(more)` | `[1, 2, ...more]` |
| Push an array onto list | `list.push.apply(list, items)` | `list.push(...items)` |
| Destructuring | `a = list[0], other = list.slice(1)` | `<span class="Apple-tab-span" style="white-space: pre;"> </span>[a, ...other] = list` |
| `new` and `apply` | `new (Date.bind.apply(Date, [null,2015,31,8]))` | `new Date(...[2015,31,8])` |


## 模板字符串

模板字符串是对常规`JavaScript`字符串的重大改进，不同于在普通字符串中使用单引号或者双引号，模板字符串的声明需要使用反撇号，如下所示：

```js
var text = `This is my first template literal`
```

因为应用反撇号，现在你可以在字符串中随意使用单双引号了，而不用考虑转义，如下：

```js
var text = `I'm "amazed" at these opportunities!`
```

模板字符串的强大功能之一是可以在其中插入JavaScript表达式

### 在字符串中插值

通过模板字符串，你可以在模板中插入任何JavaScript表达式了。当解析到表达式时，表达式会被执行，你将获得表达式的结果，下例中，我们在字符串中插入了变量`name`：

```js
var name = 'Shannon'
var text = `Hello, ${ name }!`
console.log(text)
// <- 'Hello, Shannon!'
```

不仅仅是插入变量哦，在模板字符串中你可以插入任何表达式。你可以把模板字面量中的每一个表达式都看做一个变量，然后集中于每个字符串和其它变量。不过，代码会变得更加容易维护，因为它不需要手动连接字符串和JavaScript表达式了。不过你需要保证，你的表达式中使用的变量，调用的函数在当前作用域中都是可用的。

你可以依据你自己的编码风格，来确定插入多少表达式。下面的代码中，实例化了一个`Date`对象，并把它格式化为了人类可读的格式。

```js
`The time and date is ${ new Date().toLocaleString() }.`
// <- 'the time and date is 8/26/2015, 3:15:20 PM'
```

你也可以使用数学运算符：

```js
`The result of 2+3 equals ${ 2 + 3 }`
// <- 'The result of 2+3 equals 5'
```

你甚至可用嵌套使用模板字面量，因为它们其实也是JavaScript表达式;

```js
`This template literal ${ `is ${ 'nested' }` }!`
// <- 'This template literal is nested!'
```

模板字符串的另外一个优点是支持多行字符串;

### 多行文本模板

在ES6之前，如果你想表现多行字符串，你需要使用转义，数组拼合，甚至使用使用注释符做复杂的hacks.如下所示：

```js
var escaped =
'The first line\n\
A second line\n\
Then a third line'

var concatenated =
'The first line\n' `
'A second line\n' `
'Then a third line'

var joined = [
'The first line',
'A second line',
'Then a third line'
].join('\n')
```

应用ES6，这种处理就简单多了，模板字符串默认支持多行，比起上面那些方法简单多了：

```js
var multiline =
`The first line
A second line
Then a third line`
```

当你需要，在你需要在一块`html`中插入变量信息，或者你需要在模板中展示一个列表，你可以迭代这个列表，通过相应的markup遍历，然后通过表达式返回结果。模板字符串是非常有用的，如下所示，你可以在你的模板中声明子组件。

```js
var book = {
  title: 'Modular ES6',
  excerpt: 'Here goes some properly sanitized HTML',
  tags: ['es6', 'template-literals', 'es6-in-depth']
}
var html = `<article>
  <header>
    <h1>${ book.title }</h1>
  </header>
  <section>${ book.excerpt }</section>
  <footer>
    <ul>
      ${
        book.tags
          .map(tag => `<li>${ tag }</li>`)
          .join('\n      ')
      }
    </ul>
  </footer>
</article>`
```

上述代码将得到下面这样的结果。值得注意的是你的空格得以保留，多个`li`也让我们的预期得以合适的渲染：

```js
<article>
  <header>
    <h1>Modular ES6</h1>
  </header>
  <section>Here goes some properly sanitized HTML</section>
  <footer>
    <ul>
      <li>es6</li>
      <li>template-literals</li>
      <li>es6-in-depth</li>
    </ul>
  </footer>
</article>
```

多行模板字符串的一个副作用是它的缩进，下例展示了在函数中使用包含缩进的模板字符串，可能我们希望结果没有缩进，但是结果却有四格的缩进。

```js
function getParagraph() {
  return `
    Dear Rod,

    This is a template literal string that's indented
    four spaces. However, you may have expected for it
    to be not indented at all.

    Nico
  `
}
```

尽管不完美，我们可以用下面这个功能函数去除结果中的每一行的缩进：

```js
function unindent(text) {
  return text
    .split('\n')
    .map(line => line.slice(4))
    .join('\n')
    .trim()
}
```

有时候，在插入模板之前预处理插入表达式的结果是一个好的主意。对于这些高阶应用，我们可能需要用到被称为标记模板的模板字符串新特性。

### 标记模板

默认情况下，JavaScript会把`\`解析为转义符号，具有这些符号的字符一般都有特殊的含义。比如说`\n`被解析为新行，`\u00f1`被解析为`ñ`等等。如果你不想被特殊解析，你也可以使用`String.raw`来标记模板。下面的代码片段只是了如何在使用`String.row`处理模板字符串，这里面的`\n`没有被解析为新行。

```js
var text = String.raw`"\n" is taken literally.
It'll be escaped instead of interpreted.`
console.log(text)
// "\n" is taken literally.
// It'll be escaped instead of interpreted.
```

我们添加在模板字符串之前的`String.raw`前缀就是标记模板，它被用以渲染模板，标记模板的参数可以是一组由静态部分模板构成的数组，也可以是各具结果的表达式，每个表达式有自己的参数。

一个典型的标签模板字符串如下：

```js
tag`Hello, ${ name }. I am ${ emotion } to meet you!`
```

时间上，上面标签模板会被转换为一下函数调用：

```js
tag(
  ['Hello, ', '. I am ', ' to meet you!'],
  'Maurice',
  'thrilled'
)
```

生成的字符串是通过获取模板的每个部分并在其旁边放置一个表达式生成的，直到模板中没有更多的部分为止。不过不实际使用，可能很难理解这些概念。下面我们实际使用看看。

下述代码对`tag`进行了简单的描述，它提供了模板与字符串类似的功能，但是实际上并没有使用标记模板。它使用`reduce`把`parts`数组转换为单一值，即模板字符串的计算结果。结果通过第一个`part`初始化，然后其它的`part`都通过`values`处理，在这里我们对`...values`应用了`rest`参数，目的是便于评估模板中每个表达式的结果，我们使用了具有函数返回值的箭头函数，这使得表达非常的简洁：

```js
function tag(parts, ...values) {
  return parts.reduce(
    (all, part, index) => all + values[index - 1] + part
  )
}
```

你可以像下面这样使用标记模板，不过你会发现结果和不使用标记模板是一样的，这是因为这里我们并没有做额外的处理。

```js
var name = 'Maurice'
var emotion = 'thrilled'
var text = tag`Hello, ${ name }. I am ${ emotion } to meet you!`
console.log(text)
// <- 'Hello Maurice, I am thrilled to meet you!'
```

标记模板还有很多别的用途，其中之一是转换用户输入值为大写，下面这个标记可以做这件事。我们先定义一个标记函数：

```js
function upper(parts, ...values) {
  return parts.reduce((all, part, index) =>
    all + values[index - 1].toUpperCase() + part
  )
}
var name = 'Maurice'
var emotion = 'thrilled'
upper`Hello, ${ name }. I am ${ emotion } to meet you!`
// <- 'Hello MAURICE, I am THRILLED to meet you!'
```

一个更加有用的使用是通过标记模板对对模板中的表达式进行过滤处理，现在有这么一个场景，所有的输入都来自于用户，我们可以通过使用假想的`sanitize`库来去除用户输入中的html等危险标签，这可以有效的防止XSS攻击。

```js
function sanitized(parts, ...values) {
  return parts.reduce((all, part, index) =>
    all + sanitize(values[index - 1]) + part
  )
}
var comment = 'Evil comment<iframe src="http://evil.corp">
    </iframe>'
var html = sanitized`<div>${ comment }</div>`
console.log(html)
// <- '<div>Evil comment</div>'
```

上面代码中的`iframe`差点就让破坏我们的网站了。ES6中的另外一个大的改变是提供了`let`和`const`声明。下面我们一起来学习。

## `let` & `const` 声明










