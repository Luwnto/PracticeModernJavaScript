# ES6 概要

ES6在语法层面带来了很大的非破坏性更新，我们将在本章中讨论其中的大多数内容。这些改变大多为语法糖，这意味着，这些新语法其实用ES5，也是可以写出来了，只是可能会更复杂一些。新增的变量声明方式 `let` 和 `const` 则不仅仅是语法糖，我们会在本章最后讨论一下这个。

ES6中的对象字面量有一些小的语法更新，我们从此处开始讨论。

## 对象字面量

对象字面量是指以`{}`形式什么的对象，比如下面这样：

```js
var book = {
  title: 'Modular ES6',
  author: 'Nicolas',
  publisher: 'O´Reilly'
}
```

ES6 对对象字面量语法带来了一些改进：包括，属性/方法的简洁表示，可计算的属性名等等，我们逐一来看：

### 属性的简洁表示法

有时候，我们声明的属性名中有几个他们的值所对应的变量和属性名是一致的。比如说我们有个名为`listeners` 的数组，当我们想把它赋值给对象中属性名为 `listeners` 的对象字面量时，我们需要重复写这个名字。如下所示

```js
var listeners = []
function listen() {}
var events = {
  listeners: listeners,
  listen: listen
}
```

如果你也用到过这种情况，你就利用ES6语法的新特性简写成下面这种形式了：

```js
var listeners = []
function listen() {}
var events = { listeners, listen }
```

之后我们还会讨论到，合理去重能帮助在不影响语义的情况下减少重复代码。在下面的代码片段中，我重写了浏览器的永久存储`api`，`localStroge`,作为常驻内存的`ployfill`,如果不用简写，它将显得很冗长：

```js
var store = {}
var storage = { getItem,  setItem, clear }
function getItem(key) {
  return key in store ? store[key] : null
}
function setItem(key, value) {
  store[key] = value
}
function clear() {
  store = {}
}
```

这是众多ES6中的意在减少你的代码复杂度的语法之一，一旦你习惯使用这种语法，你会发现无论是代码的可读性还是你自己的开发效率都会得以提升。

### 可计算的属性名

有时候你声明的对象中会包含一些属性名是依据JS的变量或者其它一些表达式生成，如下用ES5所写的代码所示。在这个例子中，你可以把`expertise`假设为一个你事先并不知道的函数参数：

```js
var expertise = 'journalism'
var person = {
  name: 'Sharon',
  age: 27
}
person[expertise] = {
  years: 5,
  interests: ['international', 'politics', 'internet']
}
```

ES6 中的对象字面量并不限制你只能使用静态属性名，通过可计算属性名，你可以把任何表达式放在中括号中，把它们的值当做属性名，下面的代码表示了上述ES5代码的ES6写法，看看是不是简介了许多：

```js
var expertise = 'journalism'
var person = {
  name: 'Sharon',
  age: 27,
  [expertise]: {
    years: 5,
    interests: ['international', 'politics', 'internet']
  }
}
```

不过属性你不能同时使用简写属性和属性名计算，简写属性是一种在编译阶段的用以减少重复的语法糖，而计算属性名会在运行时生效。考虑到这两种不相容的特性，以下代码会报错。在大多数情况下，二者结合使用会导致代码难易阅读，所以二者不能一起使用也许也是一个好事。

```js
var expertise = 'journalism'
var journalism = {
  years: 5,
  interests: ['international', 'politics', 'internet']
}
var person = {
  name: 'Sharon',
  age: 27,
  [expertise] // 这里会报语法错误
}
```

计算属性名的一个常用场景发生在当我们想把一个对象的某个属性添加为另外一个对象的属性，如下所示，除了使用第三方声明，我们可以采用如下简写形式：

```js
var grocery = {
  id: 'bananas',
  name: 'Bananas',
  units: 6,
  price: 10,
  currency: 'USD'
}
var groceries = {
  [grocery.id]: grocery
}
```

另一个例子是我们接受函数的参数用以构建对象。在ES5代码中，我们需要声明一个对象字面量并分配一个属性，然后动态的添加属性，然后反对这个对象。下述代码表明了这个过程，我们创建一个包裹函数可以在之后用以响应Ajax请求，当出错时返回的对象将拥有一个`error`属性及对应的描述，当执行正确时，将由一个`success`属性及对应的描述。

```js
function getEnvelope(type, description) {
  var envelope = {
    data: {}
  }
  envelope[type] = description
  return envelope
}
```

利用计算属性，我们可以更加简明的实现一样的效果：

```js
// es6
function getEnvelope(type, description) {
  return {
    data: {},
    [type]: description
  }
}
```

关于对象字面量的最后一个改进是关于函数的

### 方法定义

一般说来，你可以像添加属性一样添加函数。在下面的代码示例中，我们会创建一个小的事件发生器，它拥有一个`emitter#on`方法可以用以注册事件，还有一个`emitter#emit`方法可用以执行事件

```js
var emitter = {
  events: {},
  on: function (type, fn) {
    if (this.events[type] === undefined) {
      this.events[type] = []
    }
    this.events[type].push(fn)
  },
  emit: function (type, event) {
    if (this.events[type] === undefined) {
      return
    }
    this.events[type].forEach(function (fn) {
      fn(event)
    })
  }
}
```


在ES6中你可以使用新的语法来定义对象中的函数了，我们可以省略`function`关键字和毛航了。如下所示，用ES6 的新语法，我们的方法声明更加简洁了

```js
var emitter = {
  events: {},
  on(type, fn) {
    if (this.events[type] === undefined) {
      this.events[type] = []
    }
    this.events[type].push(fn)
  },
  emit(type, event) {
    if (this.events[type] === undefined) {
      return
    }
    this.events[type].forEach(function (fn) {
      fn(event)
    })
  }
}
```

箭头函数是ES6中声明函数的另外一种语法，它还有一些特别的优点，我们一起来看看箭头函数是什么，它该如何声明，看看在语义上它又有何不同。

## 箭头函数

传统上，在JS中，函数的声明包括函数名，一系列参数和函数体，如下所示：

```js
function name(parameters) {
  // function body
}
```

同样，也支持声明匿名函数，即不给函数命名而是把函数赋值给一个变量，属性或者直接调用函数：

```js
var example = function (parameters) {
  // function body
}
```

从ES6 开始，你可以使用箭头函数来写匿名函数了。不过要记住，这和传统的匿名函数有一些不同的地方，下例中的匿名函数看起来其实和上面我们用ES5语法写的匿名函数很想，唯一的不同在于确实`function`关键字，参数和函数体之间以`=>`相连接。

```js
var example = (parameters) => {
  // function body
}
```

尽管箭头函数看起来很像典型的匿名函数，但是他们却具有根本性的不同：箭头函数不能被直接命名，尽管允许把它们赋值给一个变量，它们不能被用做构造函数，它们也没有`prototype`属性，这意味着你不能对箭头函数使用`new`关键字，并且他们还绑定了词法作用域，这意味着他们不会修改`this`的指向。

接下来我们深入解释一下和传统函数相比二者的语义上的区别。

### 词法作用域

在箭头函数的函数体内，`this`,`arguments`,`super`都指向包含箭头函数的作用域，箭头函数本身不产生新的作用域。以如下代码为例，这里有一个名为`timer`的对象，属性`seconds`用以计数，`start`方法用以开始计时，当我们在若干秒后调用`start`方法时，将打印出当前的`seconds`值。

```js
var timer = {
  seconds: 0,
  start() {
    setInterval(() => {
      this.seconds++
    }, 1000)
  }
}
timer.start()
setTimeout(function () {
  console.log(timer.seconds)
}, 3500)
// <- 3
```

如果这里我们没用箭头函数而用的是常规的匿名函数，`this`将指向匿名函数本身，在`start`方法开头处，我们也需要使用`var self = this`这样的语法，然后在之后的匿名函数中使用`self`代替`this`，使用箭头函数，我们无需再做这些多余的操作来标注上下文一致，而可以专注于函数本身的代码了。

类似的，ES6中的箭头函数的作用域绑定意味着函数调用不能通过`.call`,`.apply`,`.bind`等改变函数的作用域。这种限制利大于害，它保证了上下文永远保持不变。

我们再来看看下面这个例子，你猜猜，最终打印出的结果是什么：


```js
function puzzle() {
  return function () {
    console.log(arguments)
  }
}
puzzle('a', 'b', 'c')(1, 2, 3)
```

答案是，对常规匿名函数而言，`arguments`指向匿名函数本身，所以此处打印的结果会是1,2,3

作为对比，我们看看下面这个例子，在本例中，箭头函数的作用域指向`puzzle`函数，这次的打印结果会是`a,b,c`,箭头函数的中调用`arguments`其实是`puzzle`函数的`arguments`

前面我们提到过，箭头函数有几种表达形式，但是现在我们看到的例子中，都是完整的箭头函数形式，下面我们看看，箭头函数的其它写法。

### 箭头函数的不同写法

一直以来我们的箭头函数是这样写的：

```js
var example = (parameters) => {
  // function body
}
```

变种之一是，当只有一个参数时，我们可以省略箭头函数参数中的括号，这样减少了括号的数量，当箭头函数是另外一个函数的方法时，这样对一些人来说是更容易阅读的。

```js
var double = value => {
  return value * 2
}
```

实践说明，对简单函数来说，箭头函数是常用的（类似上述`double`函数所示），接下来的形式更加简洁，这次我们去除了表征函数体的`{}`，直接写上`value * 2`这样的语句，当这个函数被调用时，这个语句将被调用，并把结果当做返回值返回。`return` 是静默发生的，这里不再需要花括号，不过只能使用单一表达式。

```js
var double = (value) => value * 2
```

这里也可以结合上面说的两种简写，而得到更加简洁的形式

```js
var double = value => value * 2
```

现在，你对箭头函数有了一定的理解，下面我们结合它的优点，并说明它们在何时会非常有用。

### 箭头函数的优点和使用示例

不过事先得声明一点，我们并不应该盲目的在一切地方采用`ES6`,是否使用新语法的原则是看采用了新语法能否在实质上改善代码的可读性和可维护性。ES6并没有在任何地方比我们一直写的ES5好，过渡对待ES6 并不好。

在一些情况下，箭头函数可能并非最好的工具，比如说，你有一个包含若干行代码的复杂函数，使用`=>`代替`function`关键字可能很难改善你的代码。箭头函数用在简单的代码时是有效的，`function`关键字及相应的语法标准是组成函数表达式的重要部分。

合理的命名和添加作用域能让函数更利于阅读和看明白，箭头函数并不能直接命名，但是却可以通过复制给变量的形式实现间接命名，比如如下代码中，我们把箭头函数赋值给变量 `throwError`，当函数被调用时，值是一段错误，通过追溯我们可以找到报错的箭头函数是`throwError`.

```js
var throwError = message => {
  throw new Error(message)
}
throwError('this is a warning')
<- Uncaught Error: this is a warning
  at throwError
```


当所定义的函数需要采用和外部一样的作用域时，箭头函数是简洁且有效的，这类的定义使得你的函数在一些情况下很简洁，这在某些函数式编程的情况下非常有效，比如我们使用`.map`,`.filter`,`.reduce`时。如下所示

```js
[1, 2, 3, 4]
  .map(value => value * 2)
  .filter(value => value > 2)
  .forEach(value => console.log(value))
// <- 4
// <- 6
// <- 8
```

### 箭头函数省写形式返回对象字面量的一些问题

当你想以简洁的形式返回一个对象时，你需要用小括号括起来你想返回的对象。否则，浏览器会把对象的`{}`解析为箭头函数的开始和结束，把里面的内容解析为函数体。

```js
// 正确的使用形式
var objectFactory = () => ({ modular: 'es6' })
```

在下面这个错误示例中，箭头函数把花括号解析为函数体，`number`被解析为`label`,`value`表达式并没有做任何事情，由于我们现在有了函数体，有没有做任何返回值，下述代码的结果就会是`undefined`了。

```js
[1, 2, 3].map(value => { number: value })
// <- [undefined, undefined, undefined]
```

当我们返回的对象字面量不止一个值的时候，浏览器编译器不能正确解析第二个参数，因此会抛出语法错误。

```js
[1, 2, 3].map(value => { number: value, verified: true })
// <- SyntaxError
```

把返回的对象字面量包裹在小括号中能解决这个问题，这样浏览器就可以正确的解析了：

```js
[1, 2, 3].map(value => ({ number: value, verified: true }))
/* <- [
  { number: 1, verified: true },
  { number: 2, verified: true },
  { number: 3, verified: true }]
*/
```

## 分配解构

解构是ES6提供的最灵活和富于表现的特性了。也是最简单的特性之一，它可以按你所需绑定多个变量，并可应用于对象，数组甚至函数参数。我们一个个的来看，先从对象说起吧。

### 对象解构

设想你有一个程序，这个程序中包含一些漫画人物，Bruce Wayne 就是其中之一，现在你想引用描述它的对象中的一个属性，可能你会按下面说的这样做。

```js
// 描述Bruce Wayne的对象
var character = {
  name: 'Bruce',
  pseudonym: 'Batman',
  metadata: {
    age: 34,
    gender: 'male'
  },
  batarang: ['gas pellet', 'bat-mobile control', 'bat-cuffs']
}
```

如果你想把一个名为`pseudonym` 的对象指向`character.pseudonym`,你可以写下面这样的ES5代码，这在你想在程序中多次引用这个属性而又不想多敲字符时是很常见的。

```js
var pseudonym = character.pseudonym
```

通过结构赋值，语法能看起来更清晰。如下所示，你不再需要写两次`pseudonym`了

```js
var { pseudonym } = character
```

如同你可以使用`var`加逗号在同时声明多个变量一样，你同样可以在花括号内通过解构声明多个变量。

```js
var { pseudonym, name } = character
```

类似的，你可以混合使用解构和常规的自定义变量，尽管这样写初看起来让人觉得疑惑，但是是否使用还是取决于你所遵循的代码风格中对变量定义的描述。不过，无论怎么说来，解构语法确实表现出了其灵活性。

```js
var { pseudonym } = character, two = 2
```

比如说你现在有这样的需求，你想提取出`pseudonym`属性，但是想要把它赋值给变量 `alias`,你可以按照如下方法使用解构，赋予该值以别名（`aliasing`），这里我们取的别名为`alias`,当然你可以取任何你想取的名字。

```js
var { pseudonym: alias } = character
console.log(alias)
// <- 'Batman'
```

上述代码初看起来可能也没有用ES5语法时那么简洁，但是如果当你把解构用于多层结构时就能体会到它带来的好处了，看下面这个例子。

```js
var { metadata: { gender } } = character
```

当然，多层解构也是可以赋予别名的，这样可以方便的更改子层属性的名称：

```js
var { metadata: { gender: characterGender } } = character
```

上面描述的场景是很常见的，因为属性值常常位于宿主对象中，尽管`palette.color.code`也具有较好的描述性，`code`这个词可以指代的意义有点太广了，使用别名`colorCode`可以帮助你结合上下文有一个语义更好的值。

在ES5 中，当你调用一个未曾声明的值时，你会得到`undefined`:

```js
console.log(character.boots)
// <- undefined
console.log(character['boots'])
// <- undefined
```

使用解构，情况也是类似的，当你声明了一个不存在属性的解构变量，你也会得到`undefined`.

```js
var { boots } = character
console.log(boots)
// <- undefined
```

深层的结构不存在的值（`null`或`undefined`）时，程序会抛出异常，这一点和你试图调用`null`或`undefined`的属性值时表现是一样的。

```js
var { boots: { size } } = character
// <- Exception
var { missing } = null
// <- Exception
```

解构其实就是语法糖，如果转换为下面这样的语法，你肯定就能很清楚的明白为什么会抛出异常了。

```js
var nothing = null
var missing = nothing.missing
// <- Exception
```

回到解构，当属性值为`undefined`时，你可以给属性值添加默认值，属性值可以是数值，字符串，函数，对象，甚至指向其它变量：

```js
var { boots = { size: 10 } } = character
console.log(boots)
// <- { size: 10 }
```

对于嵌套解构，同样可以赋予默认值

```js
var { metadata: { enemy = 'Satan' } } = character
console.log(enemy)
// <- 'Satan'
```

默认值和别名也可以一起使用，需要注意的是你需要把别名放在前面，默认值放在后面：

```js
var { boots: footwear = { size: 10 } } = character
```

解构语法同样支持计算属性名，不过要这样使用，你需要用别名，这是因为计算属性名允许任何类似的表达式，这样会导致编译器无法识别变量名，看下面这个示例：

```js
var { ['boo' + 'ts']: characterBoots } = character
console.log(characterBoots)
// <- true
```

解构有时候作用也没那么大，连续语句`characterBoots = character[type]`通常看起来比`{ [type]: characterBoots } = character`更简单，这意味着在当你想要以对象字面量的形式声明属性时，对象解构才是有优势的。

这就是在对象中使用解构的方法了，下面看看在数组中该如何使用。

### 数组解构

数组解构的语法和对象解构是类似的。下例中`coordinates`对象被解构为两个变量 `x,y`.值得注意的是，这里我们用的是中括号而非花括号，这表明这里是数组解构而非对象解构。通过数组解构你不需要使用`x = coordinates[0]`这样的语法了，通过解构不使用索引值，你也可以清楚的表达明白你的意思。

```js
var coordinates = [12, -7]
var [x, y] = coordinates
console.log(x)
// <- 12
```

数组解构也允许你跳过你不想用到的值：

```js
var names = ['James', 'L.', 'Howlett']
var [ firstName, , lastName ] = names
console.log(lastName)
// <- 'Howlett'
```

和对象解构一样，数组解构也允许你使用默认值：

```js
var names = ['James', 'L.']
var [ firstName = 'John', , lastName = 'Doe' ] = names
console.log(lastName)
// <- 'Doe'
```

在ES5中，你想交换两个变量的值通常要用到第三个变量，如下所示：

```js
var left = 5
var right = 7
var aux = left
left = right
right = aux
```

使用解构，可以避免使用第三个变量`aux`,而是你专注于你的意图，

```js
var left = 5
var right = 7
[left, right] = [right, left]
```

关于解构，我们想要聊的最后一方面是关于函数的

### 函数默认参数

ES6中的函数也享受到了分配默认值带来的好处，下例中我们就给参数 `exponent`分配了一个默认值：

```js
function powerOf(base, exponent = 2) {
  return Math.pow(base, exponent)
}
```

箭头函数同样支持使用默认值，需要注意的是，就算只有一个参数，如果要赋予默认值，我们还是需要用小括号括起参数部分。

```js
var double = (input = 0) => input * 2
```

就像和一些其它语言一样，默认值不仅仅限于最右面的参数。你可以给任何位置的任何参数提供默认值。

```js
function sumOf(a = 1, b = 2, c = 3) {
  return a + b + c
}
console.log(sumOf(undefined, undefined, 4))
// <- 1 + 2 + 4 = 7
```

在JS中，给一个函数提供一个包含若干属性的对象字面量做为参数并不常见，不过你可以按下面这样的方式使用：

```js
var defaultOptions = { brand: 'Volkswagen', make: 1999 }
function carFactory(options = defaultOptions) {
  console.log(options.brand)
  console.log(options.make)
}
carFactory()
// <- 'Volkswagen'
// <- 1999
```

不过这样也要一定的问题，就是如果你调用函数时传入的参数只包含一个属性，另一个属性的默认值会丢失：

```js
carFactory({ make: 2000 })
// <- undefined
// <- 2000
```

通过混合使用解构和函数默认值，我们可以解决这个问题。

### 函数参数解构












