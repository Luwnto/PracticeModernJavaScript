# ES6 概要

ES6在语法层面带来了很大的非破坏性更新，我们将在本章中讨论其中的大多数内容。这些改变大多为语法糖，这意味着，这些新语法其实用ES5，也是可以写出来了，只是可能会更复杂一些。新增的变量声明方式 `let` 和 `const` 则不仅仅是语法糖，我们会在本章最后讨论一下这个。

ES6中的对象字面量有一些小的语法更新，我们从此处开始讨论。

## 对象字面量

对象字面量是指以`{}`形式什么的对象，比如下面这样：

```js
var book = {
  title: 'Modular ES6',
  author: 'Nicolas',
  publisher: 'O´Reilly'
}
```

ES6 对对象字面量语法带来了一些改进：包括，属性/方法的简洁表示，可计算的属性名等等，我们逐一来看：

### 属性的简洁表示法

有时候，我们声明的属性名中有几个他们的值所对应的变量和属性名是一致的。比如说我们有个名为`listeners` 的数组，当我们想把它赋值给对象中属性名为 `listeners` 的对象字面量时，我们需要重复写这个名字。如下所示

```js
var listeners = []
function listen() {}
var events = {
  listeners: listeners,
  listen: listen
}
```

如果你也用到过这种情况，你就利用ES6语法的新特性简写成下面这种形式了：

```js
var listeners = []
function listen() {}
var events = { listeners, listen }
```

之后我们还会讨论到，合理去重能帮助在不影响语义的情况下减少重复代码。在下面的代码片段中，我重写了浏览器的永久存储`api`，`localStroge`,作为常驻内存的`ployfill`,如果不用简写，它将显得很冗长：

```js
var store = {}
var storage = { getItem,  setItem, clear }
function getItem(key) {
  return key in store ? store[key] : null
}
function setItem(key, value) {
  store[key] = value
}
function clear() {
  store = {}
}
```

这是众多ES6中的意在减少你的代码复杂度的语法之一，一旦你习惯使用这种语法，你会发现无论是代码的可读性还是你自己的开发效率都会得以提升。

### 可计算的属性名

有时候你声明的对象中会包含一些属性名是依据JS的变量或者其它一些表达式生成，如下用ES5所写的代码所示。在这个例子中，你可以把`expertise`假设为一个你事先并不知道的函数参数：

```js
var expertise = 'journalism'
var person = {
  name: 'Sharon',
  age: 27
}
person[expertise] = {
  years: 5,
  interests: ['international', 'politics', 'internet']
}
```

ES6 中的对象字面量并不限制你只能使用静态属性名，通过可计算属性名，你可以把任何表达式放在中括号中，把它们的值当做属性名，下面的代码表示了上述ES5代码的ES6写法，看看是不是简介了许多：

```js
var expertise = 'journalism'
var person = {
  name: 'Sharon',
  age: 27,
  [expertise]: {
    years: 5,
    interests: ['international', 'politics', 'internet']
  }
}
```

不过属性你不能同时使用简写属性和属性名计算，简写属性是一种在编译阶段的用以减少重复的语法糖，而计算属性名会在运行时生效。考虑到这两种不相容的特性，以下代码会报错。在大多数情况下，二者结合使用会导致代码难易阅读，所以二者不能一起使用也许也是一个好事。

```js
var expertise = 'journalism'
var journalism = {
  years: 5,
  interests: ['international', 'politics', 'internet']
}
var person = {
  name: 'Sharon',
  age: 27,
  [expertise] // 这里会报语法错误
}
```

计算属性名的一个常用场景发生在当我们想把一个对象的某个属性添加为另外一个对象的属性，如下所示，除了使用第三方声明，我们可以采用如下简写形式：

```js
var grocery = {
  id: 'bananas',
  name: 'Bananas',
  units: 6,
  price: 10,
  currency: 'USD'
}
var groceries = {
  [grocery.id]: grocery
}
```

另一个例子是我们接受函数的参数用以构建对象。在ES5代码中，我们需要声明一个对象字面量并分配一个属性，然后动态的添加属性，然后反对这个对象。下述代码表明了这个过程，我们创建一个包裹函数可以在之后用以响应Ajax请求，当出错时返回的对象将拥有一个`error`属性及对应的描述，当执行正确时，将由一个`success`属性及对应的描述。

```js
function getEnvelope(type, description) {
  var envelope = {
    data: {}
  }
  envelope[type] = description
  return envelope
}
```

利用计算属性，我们可以更加简明的实现一样的效果：

```js
// es6
function getEnvelope(type, description) {
  return {
    data: {},
    [type]: description
  }
}
```

关于对象字面量的最后一个改进是关于函数的

### 方法定义

一般说来，你可以像添加属性一样添加函数。在下面的代码示例中，我们会创建一个小的事件发生器，它拥有一个`emitter#on`方法可以用以注册事件，还有一个`emitter#emit`方法可用以执行事件

```js
var emitter = {
  events: {},
  on: function (type, fn) {
    if (this.events[type] === undefined) {
      this.events[type] = []
    }
    this.events[type].push(fn)
  },
  emit: function (type, event) {
    if (this.events[type] === undefined) {
      return
    }
    this.events[type].forEach(function (fn) {
      fn(event)
    })
  }
}
```


在ES6中你可以使用新的语法来定义对象中的函数了，我们可以省略`function`关键字和毛航了。如下所示，用ES6 的新语法，我们的方法声明更加简洁了

```js
var emitter = {
  events: {},
  on(type, fn) {
    if (this.events[type] === undefined) {
      this.events[type] = []
    }
    this.events[type].push(fn)
  },
  emit(type, event) {
    if (this.events[type] === undefined) {
      return
    }
    this.events[type].forEach(function (fn) {
      fn(event)
    })
  }
}
```

箭头函数是ES6中声明函数的另外一种语法，它还有一些特别的优点，我们一起来看看箭头函数是什么，它该如何声明，看看在语义上它又有何不同。

## 箭头函数

传统上，在JS中，函数的声明包括函数名，一系列参数和函数体，如下所示：

```js
function name(parameters) {
  // function body
}
```

同样，也支持声明匿名函数，即不给函数命名而是把函数赋值给一个变量，属性或者直接调用函数：

```js
var example = function (parameters) {
  // function body
}
```

从ES6 开始，你可以使用箭头函数来写匿名函数了。不过要记住，这和传统的匿名函数有一些不同的地方，下例中的匿名函数看起来其实和上面我们用ES5语法写的匿名函数很想，唯一的不同在于确实`function`关键字，参数和函数体之间以`=>`相连接。

```js
var example = (parameters) => {
  // function body
}
```

尽管箭头函数看起来很像典型的匿名函数，但是他们却具有根本性的不同：箭头函数不能被直接命名，尽管允许把它们赋值给一个变量，它们不能被用做构造函数，它们也没有`prototype`属性，这意味着你不能对箭头函数使用`new`关键字，并且他们还绑定了词法作用域，这意味着他们不会修改`this`的指向。

接下来我们深入解释一下和传统函数相比二者的语义上的区别。

### 词法作用域

在箭头函数的函数体内，`this`,`arguments`,`super`都指向包含箭头函数的作用域，箭头函数本身不产生新的作用域。以如下代码为例，这里有一个名为`timer`的对象，属性`seconds`用以计数，`start`方法用以开始计时，当我们在若干秒后调用`start`方法时，将打印出当前的`seconds`值。

```js
var timer = {
  seconds: 0,
  start() {
    setInterval(() => {
      this.seconds++
    }, 1000)
  }
}
timer.start()
setTimeout(function () {
  console.log(timer.seconds)
}, 3500)
// <- 3
```

如果这里我们没用箭头函数而用的是常规的匿名函数，`this`将指向匿名函数本身，在`start`方法开头处，我们也需要使用`var self = this`这样的语法，然后在之后的匿名函数中使用`self`代替`this`，使用箭头函数，我们无需再做这些多余的操作来标注上下文一致，而可以专注于函数本身的代码了。

类似的，ES6中的箭头函数的作用域绑定意味着函数调用不能通过`.call`,`.apply`,`.bind`等改变函数的作用域。这种限制利大于害，它保证了上下文永远保持不变。

我们再来看看下面这个例子，你猜猜，最终打印出的结果是什么：


```js
function puzzle() {
  return function () {
    console.log(arguments)
  }
}
puzzle('a', 'b', 'c')(1, 2, 3)
```

答案是，对常规匿名函数而言，`arguments`指向匿名函数本身，所以此处打印的结果会是1,2,3

作为对比，我们看看下面这个例子，在本例中，箭头函数的作用域指向`puzzle`函数，这次的打印结果会是`a,b,c`,箭头函数的中调用`arguments`其实是`puzzle`函数的`arguments`

前面我们提到过，箭头函数有几种表达形式，但是现在我们看到的例子中，都是完整的箭头函数形式，下面我们看看，箭头函数的其它写法。

### 箭头函数的不同写法

一直以来我们的箭头函数是这样写的：

```js
var example = (parameters) => {
  // function body
}
```

变种之一是，当只有一个参数时，我们可以省略箭头函数参数中的括号，这样减少了括号的数量，当箭头函数是另外一个函数的方法时，这样对一些人来说是更容易阅读的。

```js
var double = value => {
  return value * 2
}
```

实践说明，对简单函数来说，箭头函数是常用的（类似上述`double`函数所示），接下来的形式更加简洁，这次我们去除了表征函数体的`{}`，直接写上`value * 2`这样的语句，当这个函数被调用时，这个语句将被调用，并把结果当做返回值返回。`return` 是静默发生的，这里不再需要花括号，不过只能使用单一表达式。

```js
var double = (value) => value * 2
```

这里也可以结合上面说的两种简写，而得到更加简洁的形式

```js
var double = value => value * 2
```

现在，你对箭头函数有了一定的理解，下面我们结合它的优点，并说明它们在何时会非常有用。

### 箭头函数的优点和使用示例

不过事先得声明一点，我们并不应该盲目的在一切地方采用`ES6`,是否使用新语法的原则是看采用了新语法能否在实质上改善代码的可读性和可维护性。ES6并没有在任何地方比我们一直写的ES5好，过渡对待ES6 并不好。

在一些情况下，箭头函数可能并非最好的工具，比如说，你有一个包含若干行代码的复杂函数，使用`=>`代替`function`关键字可能很难改善你的代码。箭头函数用在简单的代码时是有效的，`function`关键字及相应的语法标准是组成函数表达式的重要部分。

合理的命名和添加作用域能让函数更利于阅读和看明白，箭头函数并不能直接命名，但是却可以通过复制给变量的形式实现间接命名，比如如下代码中，我们把箭头函数赋值给变量 `throwError`，当函数被调用时，值是一段错误，通过追溯我们可以找到报错的箭头函数是`throwError`.

```js
var throwError = message => {
  throw new Error(message)
}
throwError('this is a warning')
<- Uncaught Error: this is a warning
  at throwError
```


当所定义的函数需要采用和外部一样的作用域时，箭头函数是简洁且有效的，这类的定义使得你的函数在一些情况下很简洁，这在某些函数式编程的情况下非常有效，比如我们使用`.map`,`.filter`,`.reduce`时。如下所示

```js
[1, 2, 3, 4]
  .map(value => value * 2)
  .filter(value => value > 2)
  .forEach(value => console.log(value))
// <- 4
// <- 6
// <- 8
```

### 箭头函数省写形式返回对象字面量的一些问题

当你想以简洁的形式返回一个对象时，你需要用小括号括起来你想返回的对象。否则，浏览器会把对象的`{}`解析为箭头函数的开始和结束，把里面的内容解析为函数体。

```js
// 正确的使用形式
var objectFactory = () => ({ modular: 'es6' })
```

在下面这个错误示例中，箭头函数把花括号解析为函数体，`number`被解析为`label`,`value`表达式并没有做任何事情，由于我们现在有了函数体，有没有做任何返回值，下述代码的结果就会是`undefined`了。

```js
[1, 2, 3].map(value => { number: value })
// <- [undefined, undefined, undefined]
```

当我们返回的对象字面量不止一个值的时候，浏览器编译器不能正确解析第二个参数，因此会抛出语法错误。

```js
[1, 2, 3].map(value => { number: value, verified: true })
// <- SyntaxError
```

把返回的对象字面量包裹在小括号中能解决这个问题，这样浏览器就可以正确的解析了：

```js
[1, 2, 3].map(value => ({ number: value, verified: true }))
/* <- [
  { number: 1, verified: true },
  { number: 2, verified: true },
  { number: 3, verified: true }]
*/
```




