# ES6 概要

ES6在语法层面带来了很大的非破坏性更新，我们将在本章中讨论其中的大多数内容。这些改变大多为语法糖，这意味着，这些新语法其实用ES5，也是可以写出来了，只是可能会更复杂一些。新增的变量声明方式 `let` 和 `const` 则不仅仅是语法糖，我们会在本章最后讨论一下这个。

ES6中的对象字面量有一些小的语法更新，我们从此处开始讨论。

## 对象字面量

对象字面量是指以`{}`形式什么的对象，比如下面这样：

```js
var book = {
  title: 'Modular ES6',
  author: 'Nicolas',
  publisher: 'O´Reilly'
}
```

ES6 对对象字面量语法带来了一些改进：包括，属性/方法的简洁表示，可计算的属性名等等，我们逐一来看：

### 属性的简洁表示法

有时候，我们声明的属性名中有几个他们的值所对应的变量和属性名是一致的。比如说我们有个名为`listeners` 的数组，当我们想把它赋值给对象中属性名为 `listeners` 的对象字面量时，我们需要重复写这个名字。如下所示

```js
var listeners = []
function listen() {}
var events = {
  listeners: listeners,
  listen: listen
}
```

如果你也用到过这种情况，你就利用ES6语法的新特性简写成下面这种形式了：

```js
var listeners = []
function listen() {}
var events = { listeners, listen }
```

之后我们还会讨论到，合理去重能帮助在不影响语义的情况下减少重复代码。在下面的代码片段中，我重写了浏览器的永久存储`api`，`localStroge`,作为常驻内存的`ployfill`,如果不用简写，它将显得很冗长：

```js
var store = {}
var storage = { getItem,  setItem, clear }
function getItem(key) {
  return key in store ? store[key] : null
}
function setItem(key, value) {
  store[key] = value
}
function clear() {
  store = {}
}
```

这是众多ES6中的意在减少你的代码复杂度的语法之一，一旦你习惯使用这种语法，你会发现无论是代码的可读性还是你自己的开发效率都会得以提升。

### 可计算的属性名

有时候你声明的对象中会包含一些属性名是依据JS的变量或者其它一些表达式生成，如下用ES5所写的代码所示。在这个例子中，你可以把`expertise`假设为一个你事先并不知道的函数参数：

```js
var expertise = 'journalism'
var person = {
  name: 'Sharon',
  age: 27
}
person[expertise] = {
  years: 5,
  interests: ['international', 'politics', 'internet']
}
```

ES6 中的对象字面量并不限制你只能使用静态属性名，通过可计算属性名，你可以把任何表达式放在中括号中，把它们的值当做属性名，下面的代码表示了上述ES5代码的ES6写法，看看是不是简介了许多：

```js
var expertise = 'journalism'
var person = {
  name: 'Sharon',
  age: 27,
  [expertise]: {
    years: 5,
    interests: ['international', 'politics', 'internet']
  }
}
```

不过属性你不能同时使用简写属性和属性名计算，简写属性是一种在编译阶段的用以减少重复的语法糖，而计算属性名会在运行时生效。考虑到这两种不相容的特性，以下代码会报错。在大多数情况下，二者结合使用会导致代码难易阅读，所以二者不能一起使用也许也是一个好事。

```js
var expertise = 'journalism'
var journalism = {
  years: 5,
  interests: ['international', 'politics', 'internet']
}
var person = {
  name: 'Sharon',
  age: 27,
  [expertise] // 这里会报语法错误
}
```

计算属性名的一个常用场景发生在当我们想把一个对象的某个属性添加为另外一个对象的属性，如下所示，除了使用第三方声明，我们可以采用如下简写形式：

```js
var grocery = {
  id: 'bananas',
  name: 'Bananas',
  units: 6,
  price: 10,
  currency: 'USD'
}
var groceries = {
  [grocery.id]: grocery
}
```

另一个例子是我们接受函数的参数用以构建对象。在ES5代码中，我们需要声明一个对象字面量并分配一个属性，然后动态的添加属性，然后反对这个对象。下述代码表明了这个过程，我们创建一个包裹函数可以在之后用以响应Ajax请求，当出错时返回的对象将拥有一个`error`属性及对应的描述，当执行正确时，将由一个`success`属性及对应的描述。

```js
function getEnvelope(type, description) {
  var envelope = {
    data: {}
  }
  envelope[type] = description
  return envelope
}
```

利用计算属性，我们可以更加简明的实现一样的效果：

```js
// es6
function getEnvelope(type, description) {
  return {
    data: {},
    [type]: description
  }
}
```

关于对象字面量的最后一个改进是关于函数的

### 方法定义

一般说来，你可以像添加属性一样添加函数。在下面的代码示例中，我们会创建一个小的事件发生器，它拥有一个`emitter#on`方法可以用以注册事件，还有一个`emitter#emit`方法可用以执行事件

```js
var emitter = {
  events: {},
  on: function (type, fn) {
    if (this.events[type] === undefined) {
      this.events[type] = []
    }
    this.events[type].push(fn)
  },
  emit: function (type, event) {
    if (this.events[type] === undefined) {
      return
    }
    this.events[type].forEach(function (fn) {
      fn(event)
    })
  }
}
```


在ES6中你可以使用新的语法来定义对象中的函数了，我们可以省略`function`关键字和毛航了。如下所示，用ES6 的新语法，我们的方法声明更加简洁了

```js
var emitter = {
  events: {},
  on(type, fn) {
    if (this.events[type] === undefined) {
      this.events[type] = []
    }
    this.events[type].push(fn)
  },
  emit(type, event) {
    if (this.events[type] === undefined) {
      return
    }
    this.events[type].forEach(function (fn) {
      fn(event)
    })
  }
}
```

箭头函数是ES6中声明函数的另外一种语法，它还有一些特别的优点，我们一起来看看箭头函数是什么，它该如何声明，看看在语义上它又有何不同。

## 箭头函数

传统上，在JS中，函数的声明包括函数名，一系列参数和函数体，如下所示：

```js
function name(parameters) {
  // function body
}
```

同样，也支持声明匿名函数，即不给函数命名而是把函数赋值给一个变量，属性或者直接调用函数：

```js
var example = function (parameters) {
  // function body
}
```

从ES6 开始，你可以使用箭头函数来写匿名函数了。不过要记住，这和传统的匿名函数有一些不同的地方，下例中的匿名函数看起来其实和上面我们用ES5语法写的匿名函数很想，唯一的不同在于确实`function`关键字，参数和函数体之间以`=>`相连接。

```js
var example = (parameters) => {
  // function body
}
```

尽管箭头函数看起来很像典型的匿名函数，但是他们却具有根本性的不同：箭头函数不能被直接命名，尽管允许把它们赋值给一个变量，它们不能被用做构造函数，它们也没有`prototype`属性，这意味着你不能对箭头函数使用`new`关键字，并且他们还绑定了词法作用域，这意味着他们不会修改`this`的指向。

接下来我们深入解释一下和传统函数相比二者的语义上的区别。

### 词法作用域
