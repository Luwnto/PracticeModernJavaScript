# Classs,Symbols,Objects 和 Decorators

前面我们已经学习了ES6对JS的基本改进，是时候学习一些别的特性了--classes 和 symbols。ES6中新增的类（classes）提供了一种以原型链来模仿传统基于类编程的模式。而Symbol则是JavaScript中的一种新的基本类型（像字符串，布尔值，数值一样），它可以用来定义协议，本章中，我们将说明这是什么意思。本章说完类和`symbols`后将继续讨论一些新增如`ES6`的内置静态方法。

## Classes

JavaScript是一种基于原型链的语言，新增的类可以看做一种基于原型链的语法糖。原型继承和类之间的最大差别在于，类可以拓展其它类，这使得我们可以拓展内置的`Array`，而这用ES6之前的语法实现是很复杂的。

### 类基础

学习新知识之前，复习一下已存的结构是一个很好的主意，然后再看新特性给这些已有的结构带来了那些改进。基于此，本文将先简单复习基于原型链的JavaScript构造器，然后把它和ES6中新增的类语法做对比。

下面代码中，我们使用添加了若干方法的构造函数表示一种水果。构造函数的参数为水果的名称`name`和卡路里含量`calaries`，默认该水果只有一块`pieces=1`,`.chop`方法可以为该水果分隔另外一块，此外`.bite`方法，表示传入`.bite`方法的`person`将吃一口该水果，并使得饱腹感`satiety`等于总卡路里量减去剩余的水果块的卡路里量。

```js
function Fruit(name, calories) {
  this.name = name
  this.calories = calories
  this.pieces = 1
}
Fruit.prototype.chop = function () {
  this.pieces++
}
Fruit.prototype.bite = function (person) {
  if (this.pieces < 1) {
    return
  }
  const calories = this.calories / this.pieces
  person.satiety += calories
  this.calories -= calories
  this.pieces--
}
```

尽管上面的代码很简单，但是它们也足以让我们来记录一些事情了。这里我们有一个构造函数，这个构造函数接收一些参数，并在其中定义了一些事件，一些属性。下述代码表示我们如果创建`Fruit`的实例，一个`person`将该实例水果分隔为四块并吃了三口。

```js
const person = { satiety: 0 }
const apple = new Fruit('apple', 140)
apple.chop()
apple.chop()
apple.chop()
apple.bite(person)
apple.bite(person)
apple.bite(person)
console.log(person.satiety)
// <- 105
console.log(apple.pieces)
// <- 1
console.log(apple.calories)
// <- 35
```

如果我们使用的是Class，如下面代码所示，构造函数被声明为水果类的显式成员，方法遵循对象字面方法定义语法。如果我们把`class`语法和基于原型的语法做对比，你会发现我们的方法使用显式声明的同时大量减少了样本代码的使用即省略了`fruit.prototype`。事实上，将方法全部声明在`class`的块中也有助于读者理解，使得我们的类意图明确，将构造函数显式地作为`fruit`的方法成员，与基于原型的类语法相比也更容易理解。

```js
class Fruit {
  constructor(name, calories) {
    this.name = name
    this.calories = calories
    this.pieces = 1
  }
  chop() {
    this.pieces++
  }
  bite(person) {
    if (this.pieces < 1) {
      return
    }
    const calories = this.calories / this.pieces
    person.satiety += calories
    this.calories -= calories
    this.pieces--
  }
}
```

你可能注意到这里有一个容易被忽略的细节，我们的`Fruit`类的方法之间没有逗号，这里并不是我写错了，这是类语法的要求，这种要求帮忙我们避免了一种错误，即把普通的对象和类互换，它们其实是不一样的。同时这样做，也为未来类的改进做下铺垫，未来类中可能还会添加`public`或`private`类区域。

上述我们基于类的代码和基于原型链的代码是一样的。`Fruit`的行为一点也不会变，其API也没有变。基于类的方法中，我们实例化了apple，把它切为小块，然后吃掉了其中的大部分这些事情在基于类的`Fruit`中同样会做。

值得注意的是，类声明并不会被提升到作用域的顶部，就像函数声明和函数表达式一样，类也可以被声明为表达式，你可以像下述代码中这样，声明类名

```js
const Person = class {
  constructor(name) {
    this.name = name
  }
}
```

类可以作为函数的返回值，这使得创建类工厂非常容易，在下面的例子中我们创建一个动态的箭头的函数，它接受一个名为`name`的参数，然后通过`super()`把它反馈给其父类`Person`.

```js
const createPersonClass = name => class extends Person {
  constructor() {
    super(name)
  }
}
const JakePerson = createPersonClass('Jake')
const jake = new JakePerson()
```

我们将在稍后详细讨论类继承，在此之前我们先仔细看看属性和方法。

### 类中的属性和方法









