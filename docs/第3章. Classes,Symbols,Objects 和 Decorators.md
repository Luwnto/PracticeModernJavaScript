# Classs,Symbols,Objects 和 Decorators

**本章尚未完成，请先不要编辑本章**



前面我们已经学习了ES6对JS的基本改进，是时候学习一些别的特性了--classes 和 symbols。ES6中新增的类（classes）提供了一种以原型链来模仿传统基于类编程的模式。而Symbol则是JavaScript中的一种新的基本类型（像字符串，布尔值，数值一样），它可以用来定义协议，本章中，我们将说明这是什么意思。本章说完类和`symbols`后将继续讨论一些新增如`ES6`的内置静态方法。

## Classes

JavaScript是一种基于原型链的语言，新增的类可以看做一种基于原型链的语法糖。原型继承和类之间的最大差别在于，类可以拓展其它类，这使得我们可以拓展内置的`Array`，而这用ES6之前的语法实现是很复杂的。

### 类基础

学习新知识之前，复习一下已存的结构是一个很好的主意，然后再看新特性给这些已有的结构带来了那些改进。基于此，本文将先简单复习基于原型链的JavaScript构造器，然后把它和ES6中新增的类语法做对比。

下面代码中，我们使用添加了若干方法的构造函数表示一种水果。构造函数的参数为水果的名称`name`和卡路里含量`calaries`，默认该水果只有一块`pieces=1`,`.chop`方法可以为该水果分隔另外一块，此外`.bite`方法，表示传入`.bite`方法的`person`将吃一口该水果，并使得饱腹感`satiety`等于总卡路里量减去剩余的水果块的卡路里量。

```js
function Fruit(name, calories) {
  this.name = name
  this.calories = calories
  this.pieces = 1
}
Fruit.prototype.chop = function () {
  this.pieces++
}
Fruit.prototype.bite = function (person) {
  if (this.pieces < 1) {
    return
  }
  const calories = this.calories / this.pieces
  person.satiety += calories
  this.calories -= calories
  this.pieces--
}
```

尽管上面的代码很简单，但是它们也足以让我们来记录一些事情了。这里我们有一个构造函数，这个构造函数接收一些参数，并在其中定义了一些事件，一些属性。下述代码表示我们如果创建`Fruit`的实例，一个`person`将该实例水果分隔为四块并吃了三口。

```js
const person = { satiety: 0 }
const apple = new Fruit('apple', 140)
apple.chop()
apple.chop()
apple.chop()
apple.bite(person)
apple.bite(person)
apple.bite(person)
console.log(person.satiety)
// <- 105
console.log(apple.pieces)
// <- 1
console.log(apple.calories)
// <- 35
```

如果我们使用的是Class，如下面代码所示，构造函数被声明为水果类的显式成员，方法遵循对象字面方法定义语法。如果我们把`class`语法和基于原型的语法做对比，你会发现我们的方法使用显式声明的同时大量减少了样本代码的使用即省略了`fruit.prototype`。事实上，将方法全部声明在`class`的块中也有助于读者理解，使得我们的类意图明确，将构造函数显式地作为`fruit`的方法成员，与基于原型的类语法相比也更容易理解。

```js
class Fruit {
  constructor(name, calories) {
    this.name = name
    this.calories = calories
    this.pieces = 1
  }
  chop() {
    this.pieces++
  }
  bite(person) {
    if (this.pieces < 1) {
      return
    }
    const calories = this.calories / this.pieces
    person.satiety += calories
    this.calories -= calories
    this.pieces--
  }
}
```

你可能注意到这里有一个容易被忽略的细节，我们的`Fruit`类的方法之间没有逗号，这里并不是我写错了，这是类语法的要求，这种要求帮忙我们避免了一种错误，即把普通的对象和类互换，它们其实是不一样的。同时这样做，也为未来类的改进做下铺垫，未来类中可能还会添加`public`或`private`类区域。

上述我们基于类的代码和基于原型链的代码是一样的。`Fruit`的行为一点也不会变，其API也没有变。基于类的方法中，我们实例化了apple，把它切为小块，然后吃掉了其中的大部分这些事情在基于类的`Fruit`中同样会做。

值得注意的是，类声明并不会被提升到作用域的顶部，就像函数声明和函数表达式一样，类也可以被声明为表达式，你可以像下述代码中这样，声明类名

```js
const Person = class {
  constructor(name) {
    this.name = name
  }
}
```

类可以作为函数的返回值，这使得创建类工厂非常容易，在下面的例子中我们创建一个动态的箭头的函数，它接受一个名为`name`的参数，然后通过`super()`把它反馈给其父类`Person`.

```js
const createPersonClass = name => class extends Person {
  constructor() {
    super(name)
  }
}
const JakePerson = createPersonClass('Jake')
const jake = new JakePerson()
```

我们将在稍后详细讨论类继承，在此之前我们先仔细看看属性和方法。

### 类中的属性和方法

值得我们注意的是类声明中的`constructor`方法是可选的。下面用类声明和用常规构造函数声明的`Fruit`是一样的：



```javascript
class Fruit {
}
function Fruit() {
}
```



所有被传入`Log()`的参数都将作为`Log`中`constructor`的参数，这些参数可以用以初始化类的实例。



```javascript
class Log {
  constructor(...args) {
    console.log(args)
  }
}
new Log(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)
// &amp;lt;- [&apos;a&apos; &apos;b&apos; &apos;c&apos;]
```



下面的代码则表示在创建类`Counter`类的实例时，我们会为该实例初始化一个名为`count`的属性。`get next`方法则表示类`Counter`实例将有一个`next`方法，用以返回调用调用结果。



```javascript
class Counter {
  constructor(start) {
    this.count = start
  }
  get next() {
    return this.count++
  }
}
```



你可以像下面这样使用`Counter`类，每一次`.next`被调用的时候，`count`值增加1，虽然有效，但是这种方法一般说来比使用`get`属性访问器其要好，我们需要注意，不应该乱用`get`这里属性访问器。滥用属性访问器的对象一般都会变得让人疑惑。

```javascript
const counter = new Counter(2)
console.log(counter.next)
//  2
console.log(counter.next)
//  3
console.log(counter.next)
//  4
```



当与设置器配对时，访问者可能会在对象及其底层数据存储之间提供有趣的桥梁。我们可以考虑如下例子，这里我们定义了一个类，使用提供的存储`key`，它可以用来在`localStorage`中存储和取出`JSON`数据。



```javascript
class LocalStorage {
  constructor(key) {
    this.key = key
  }
  get data() {
    return JSON.parse(localStorage.getItem(this.key))
  }
  set data(data) {
    localStorage.setItem(this.key, JSON.stringify(data))
  }
}
```



你可以按下面这样使用`LocalStorage`类。所有分配给`ls.data`的值将被转换为JSON对象字符串，并存储在`localStorage`中。然后，当需要读取时，想用的`key`将用以在之前存储的内容中读取数据，以JSON的格式进行解析，并返回。

```javascript
const ls = new LocalStorage(&apos;groceries&apos;)
ls.data = [&apos;apples&apos;, &apos;bananas&apos;, &apos;grapes&apos;]
console.log(ls.data)
// &amp;lt;- [&apos;apples&apos;, &apos;bananas&apos;, &apos;grapes&apos;]
```



除了使用`getters`和`setters`,我们也可以定义常规的实例方法，前面我们已经定义过`Fruit`类。下面我们还定义了一个可以吃水果的`Person`类，我们可以实例化一个`fruit`和一个`person`，然后让`person`吃`fruit`。最后由于这个人吃完了整个水果,`person`的`satiety`(饱食度)上升到了40。

```javascript
class Person {
  constructor() {
    this.satiety = 0
  }
  eat(fruit) {
    while (fruit.pieces &amp;gt; 0) {
      fruit.bite(this)
    }
  }
}
const plum = new Fruit(&apos;plum&apos;, 40)
const person = new Person()
person.eat(plum)
console.log(person.satiety)
// &amp;lt;- 40
```



有时候我们需要在类层面上定义静态方法而不仅仅是在实例层面上定义静态方法，如果使用的是ES6之前的语法，我们将不得不把实例成员添加到原型链中，而静态方法则被直接添加入构造函数中。

```javascript
function Person() {
  this.hunger = 100
}
Person.prototype.eat = function () {
  this.hunger--
}
Person.isPerson = function (person) {
  return person instanceof Person
}
```



就像你使用`get``set`前赘定义`getter`和`setter`一样，类允许你使用通过前缀`static`定义静态方法`Persion.isPerson`。



下属代码利用了`Array#reduce`方法在类`MathHelper`中定义了一个静态方法`sum`，这个方法将用以计算所有传入所调用函数中的参数的总和。



```javascript
class MathHelper {
  static sum(...numbers) {
    return numbers.reduce((a, b) =&amp;gt; a + b)
  }
}
console.log(MathHelper.sum(1, 2, 3, 4, 5))
// &amp;lt;- 15
```



最后，还需要说明的是你可以结合`getter`，`setter`使用类静态方法，这在维持类全局状态时或者类使用单例模式时非常有用。当然你依旧可以用老方法而不用定义一个你永远不会实例化的类或者只会实例化一次的类，这就是JavaScript，一个高度灵活的语言。



### JavaScript类的拓展

你可以使用普通的JavaScript来拓展`Fruit`类，就像下面这样，我们声明子类时用到了深奥的`Parent.call(this)`以便能将参数传递给父类，以便我们可以正确地初始化子类，并把子类的接在父类的原型中。你在网上可以找到很多关于原型继承的知识，所以我们在这里就不再赘述了。



```javascript
function Banana() {
  Fruit.call(this, &apos;banana&apos;, 105)
}
Banana.prototype = Object.create(Fruit.prototype)
Banana.prototype.slice = function () {
  this.pieces = 12
}
```



鉴于需要记住这些不常用的知识，而且`Object.create`在ES5中才能使用，一般JS开发者都使用库来解决继承问题。比如说Node.js中的`util.inherits`,由于遗留问题，它通常比`Object.create`更受欢迎。



```javascript
const util = require(&apos;util&apos;)
function Banana() {
  Fruit.call(this, &apos;banana&apos;, 105)
}
util.inherits(Banana, Fruit)
Banana.prototype.slice = function () {
  this.pieces = 12
}
```



考虑到除了banana有`name`，并已有确定的`calories`,以及有额外的`slice`方法用以把banana切为12块外，Banana构造函数和`Fruit`构造函数没有区别。下面的代码表现了我们咬(bite)的时候`Banana`的行为：

```javascript
const person = { satiety: 0 }
const banana = new Banana()
banana.slice()
banana.bite(person)
console.log(person.satiety)
// &amp;lt;- 8.75
console.log(banana.pieces)
// &amp;lt;- 11
console.log(banana.calories)
// &amp;lt;- 96.25
```



Fruit类其实是被继承了，下面的代码中，我们创建了一个Banana类用以继承Fruit类，这种语法非常清晰，我们无须彻底弄明白原型的机制就可以获得我们想要的结果。如果我们想要给`Fruit`类传递参数，我们只需要使用`super`关键字即可，`super`关键字还可以用以调用存在于父类中的方法，比如说`super.chop`,它的使用不限于在`constructor`里面。



```javascript
class Banana extends Fruit {
  constructor() {
    super(&apos;banana&apos;, 105)
  }
  slice() {
    this.pieces = 12
  }
}
```



尽管`class`关键字是静态的，我们还可以结合使用JavaScript的函数的特性和灵活性。所有返回构造函数的表达式都可以用于拓展，我们因此可以有一个构造函数工厂，并它当做基类。



下面的代码中定义了一个`createJuicyFruit` 的函数，通过使用`super`我们可以给`Fruit`类传入`name`和`calories`,之后所有我们需要做的事情就是拓展`JuicyFruit` 类了。



```javascript
const createJuicyFruit = (...params) =>
  class JuicyFruit extends Fruit {
    constructor() {
      this.juice = 0
      super(...params)
    }
    squeeze() {
      if (this.calories <= 0) {
        return
      }
      this.calories -= 10
      this.juice += 3
    }
  }
class Plum extends createJuicyFruit('plum', 30) {
}
```



接下来我们来先讲述`Symbol`,了解`Symbol`对于之后我们理解迭代至关重要，这将在本章后面进行讨论。



## Symbols

Symbol是ES6提供的一种新的JavaScript的基本类型。 它代表唯一值，和字符串，数值不同的是，Symbol并没有字符的表达形式，如`text`字符串，或 `1`数值。Symbol的主要目的是用以实现协议，比如说，迭代协议使用Symbol定义对象如何被迭代，我们将在[Iterator Protocol and Iterable Protocol.]()这一节详细阐述。

有三种不同蕾西的Symbol，每一种有不同的使用方法，它们分别是
- `local Symbol`，这种类型又内置的Symbol包装对象创建，通过反射或者存储引用来使用。
- `global Symbol`,由另外一个API创建 并且全局可用；
- `well-konwn Symbol`,内置于JavaScript，用于定义内部语言行为。

我们将讨论全部这三种，看看它们分别该怎么使用，从`local Symbol`说起吧。

### Local Symbol

Symbols 可通过 `Symbol` 包装对象创建，下例中，我们创建了我们的第一个Symbol。

```js
const first = Symbol()
```

尽管你可以在`Number`或`String`前使用`new`操作符，在`Symbol`前却不能使用，否则会抛出错误，这避免了错误和注入`new Number(3) !== Number(3)`这样令人误解的行为，下述代码表现了报错是什么样的：

```js
const oops = new Symbol()
// <- TypeError, Symbol is not a constructor
```

为了调试遍历，新建的`Symbol`可以添加描述：

```js
const mystery = Symbol('my symbol')
```

和数值和字符串一样，Symbol是不可变的，但是和这些类型不同的是，Symbol是唯一的。下面代码中，描述并不影响唯一性，由相同描述创建的Symbol依旧是唯一且不相等的。

```js
console.log(Number(3) === Number(3))
// <- true
console.log(Symbol() === Symbol())
// <- false
console.log(Symbol('my symbol') === Symbol('my symbol'))
// <- false
```

Symbols的类别为`symbol`，下述代码显示了对Symbol 使用 `typeof`返回的值：

```js
console.log(typeof Symbol())
// <- 'symbol'
console.log(typeof Symbol('my symbol'))
// <- 'symbol'
```

Symbols 可以用作对象的属性名，这里我们用计算属性名来说明如何使用，如下所示，为了使用一个Symbol属性，您需要引用用于创建所述属性的Symbol。

```js
const weapon = Symbol('weapon')
const character = {
  name: 'Penguin',
  [weapon]: 'umbrella'
}
console.log(character[weapon])
// <- 'umbrella'
```

需要注意的是，许多传统的从对象中提取键的方法中对Symbol无效。下述代码表明`for...in `,`Object,keys`,`Object.getOwnPropertyNames`都不能访问到Symbol 属性。

```js
for (let key in character) {
  console.log(key)
  // <- 'name'
}
console.log(Object.keys(character))
// <- ['name']
console.log(Object.getOwnPropertyNames(character))
// <- ['name']
```

Symbol的这方面的特性表明，ES6之前的没有Symbol的代码并不会由于Symbol的出现而受影响。类似的，如下代码所示，当将对象解析为JSON时，符号属性将被丢弃。

```js
console.log(JSON.stringify(character))
// <- '{"name":"Penguin"}'
```

这意味着，Symbols绝不是隐藏属性的安全机制。即使在使用反射或序列化方法时不会发现符号属性，符号也会由专用方法揭示，如下一段代码所示。这意味着，Symbols 并非不可枚举的，只是一般情况下它不可见而已，通过`Object.getOwnPropertySymbols`我们可以获取任何对象中的所有`Symbol`.

```js
console.log(Object.getOwnPropertySymbols(character))
// <- [Symbol(weapon)]
```

现在我们已经知道了Symbol该如何使用，下面我们谈谈它该在什么时候使用？

### Symbols的使用案例

Symbols可以通过库来使用，用于将对象映射到DOM元素，比如说，一个库需要连接日历的API对象和所提供的DOM元素。ES6之前，并不存在一种清晰的方法可用用以建立DOM和对象之间的映射。你可以给DOM元素添加一个属性指向API，但是这回用自定义属性污染DOM元素，这并不是一种好的实践方法。您必须小心地使用不被其他库使用的属性键，或者更糟糕的是，将来语言本身将使用的属性。这就让您使用一个数组查找表，该表为每个DOM / API对包含一个条目。然后，在一个长期运行的程序中，随着数组查找表越来越大，慢慢的查找操作就越来越慢了。

使用Symbol则完全没有这类问题了，你不用担心定义的属性名会和将来语言中的属性名冲突，它们是唯一的。下述代码表明了如何使用Symbol建立DOM和日历API之间的映射。

```js
const cache = Symbol('calendar')
function createCalendar(el) {
  if (cache in el) { // does the symbol exist in the element?
    return el[cache] // use the cache to avoid re-instantiation
  }
  const api = el[cache] = {
    // the calendar API goes here
  }
  return api
}
```

ES6 提供的一种新数据类型`WeakMap`,它可以用于唯一地将对象映射到其他对象，而不需要使用数组或将外部属性放置在我们希望查找的对象上。和数组查找表比起来，`WeakMap`查找复杂度始终为O(1),我们将在[ Leveraging ECMAScript Collections]()一节和其它ES6内置对象详细讨论`WeakMap`。

### 通过符号定义协议

早些时候，我们假设`Symbol`用以定义协议。协议是定义行为的通信契约或约定。简单说来，库可用使用Symbol ,然后依附于该库的对象就可以使用Symbol了。

考虑下面的代码，这里我们用了一个特殊的`toJSON`方法，用以限制可以被`JSON.stringify`序列化的对象。正如你所看到的，序列化`character`对象返回了`toJSON`方法返回的对象的序列化模式。


```js
const character = {
  name: 'Thor',
  toJSON: () => ({
    key: 'value'
  })
}
console.log(JSON.stringify(character))
// <- '"{"key":"value"}"'
```

相比之下，如果`toJSON`不是一个函数，原始的`character`对象将被序列化，`toJSON`只是其中一个属性，就像下面代码中那样。出现这种不一致的原因在于使用了常规属性来定义行为。

```js
const character = {
  name: 'Thor',
  toJSON: true
}
console.log(JSON.stringify(character))
// <- '"{"name":"Thor","toJSON":true}"'
```

让`toJSON`修饰符是一个Symbol则更好，原因是它不会影响其它的对象属性，考虑到symbols 是唯一的，永远不会被序列化的，不调用`Object.getOwnPropertySymbols`永远不会暴露出来的，当制定一个`JSON.stringify`和对象如何被序列化的协议时，使用Symbol将是一种更好的选择。以下代码表明了如何使用Symbol定义`stringify`函数的序列化行为。

```js
const json = Symbol('alternative to toJSON')
const character = {
  name: 'Thor',
  [json]: () => ({
    key: 'value'
  })
}
stringify(character)
function stringify(target) {
  if (json in target) {
    return JSON.stringify(target[json]())
  }
  return JSON.stringify(target)
}
```

使用Symbol 意味着我们需要使用计算属性名来在对象字面量中直接定义`json`的行为。它同样意味着，这种行为不会和其它的用户定义属性或者以后JS语言可能会加入的属性有冲突。另一个不同的地方在于，用户通过`stringify `函数是可以使用`json`符号的，因此它们可以自定义行为，我们可以通过下面的代码通过`stringify`暴露`json`符号，如下所示，这将绑定`stringify`函数和修改其行为的符号。

```js
stringify.as = json
```

通过暴露`stringify`函数，我们可以使用`stringify.as`符号了，这就让使用者可以通过自定义的符号来调整对象的行为了。

当谈到使用使用符号来描述行为的优点时，与传递给`stringify`函数一个选项成对比的是，我们还需要考虑以下几点。首先，给函数添加选项参数改变了它的公有API，而改变一个函数的内在行为来支持另外一个符号不会影响公有API。使用每一个选项包含不同对象的`object`对象缓和了这一影响，不过在每一个函数调用中要求一个`options`对象并不总是很方便。

通过符号定义行为的优点是你可以增强或自定义对象的行为而不影响除了所分配的符号值之外的所有东西，原始的内部实现机制很可能也不会受影响。使用符号的好久就在于，当引入新的语言特性时，您不会受到名称冲突的影响。

除了local Symbol，还有一种`global symbol`它可以跨代码域访问，且听我细细道来。

### 全局符号

代码域指的是任何JavaScript表达式的执行上下文，比如说你的应用当前运行的页面，页面中的`<iframe>`，`eval`运行的脚本，以及任意类型的`worker`，比如说`web worker`,`service workers`或者`shared workers`,这些执行上下文每一种都有其全局对象比如说页面的全局对象`window`不能被`ServiceWorker`使用。与此不同的是，全局符号可以被任何代码域访问。

有两种和运行时的全局符号交互的方法，它们是`Symbol.for`和`Symbol.keyFor`。我们看看它们分别如何使用？

#### 通过`Symbol.for(key)`获取symbols

`Symbol.for(key)`方法将在运行时范围符号注册表中查找`key`,如果全局注册表中存在`key`则返回该`Symbol`，如果不存在该`key`的Symbol，在全局注册表中将创建以该`key`代表的Symbol，这意味着，`Symbol.for(key)`是幂等的，它先查找，不存在就创建，然后返回查找或新创建的Symbol。

下面的代码中，第一次调用`Symbol.for`创建了一个标记为`example`的Symbol，并把它添加到注册表，并返回该Symbol，第二次调用`Symbol.for`由于该`key`已经在注册表中存在，返回了相同的符号，与第一次的返回值相同。

```js
const example = Symbol.for('example')
console.log(example === Symbol.for('example'))
// <- true
```

全局的符号注册表通过`key`跟踪符号，需要注意的是`key`也将用做新创建的Symbol的`description`。考虑到这些符号在运行时是全局的，你可能需要在符号keys之前添加前缀用以区分你的逐渐或者库，用以避免潜在的命名冲突。

#### 使用`Symbol.keyFor(symbol)`来提取符号的keys

比如说现在存在一个符号`symbol`，`Symbol.keyFor(symbol)`将返回全局注册表中该`symbol`对应的`key`值。下面的例子表明了我们如何使用`Symbol.keyFor`来获取对应`Symbol`的`key`:

```js
const example = Symbol.for('example')
console.log(Symbol.keyFor(example))
// <- 'example'
```

请注意，如果该`symbol`不在全局运行注册表中，该方法将返回`undefined`。

```js
console.log(Symbol.keyFor(Symbol()))
// <- undefined
```

同样需要注意的是在全局符号注册表中不可能用`local Symbol`匹配到值，即使它们的描述相同也是如此，这是因为，local Symbol 不是全局符号注册表的一部分，如下代码所示：

```js
const example = Symbol.for('example')
console.log(Symbol.keyFor(Symbol('example')))
// <- undefined
```

现在你已经知道了全局符号注册表的两种用法，下面我们来看看还有那些别的值得考虑的因素。


#### 最佳实践和需要考虑的因素

全局的运行注册表意味着符号可以被任何代码域获取，在任何代码域中调用，全局的注册表都将返回相同的对象指向。下面的例子中，我们展示了`Symbol.for`是如何在一个页面和一个`<iframe>`中返回相同的Symbol的。

```js
const d = document
const frame = d.body.appendChild(d.createElement('iframe'))
const framed = frame.contentWindow
const s1 = window.Symbol.for('example')
const s2 = framed.Symbol.for('example')
console.log(s1 === s2)
// <- true
```

使用全局符号需要权衡，一方面，它使得库可以容易的对外暴露其Symbol，另一方面，它们也可以使用`local Symbol`暴露他们的API，很明显，符号注册表在符号需要夸代码域使用时非常有用，比如说跨`ServiceWorker`和浏览器页面。当你不想使用引用而直接想直接使用`Symbol`时，全局符号也非常方便，你可以直接调用，因为一个`key`永远对应的都是同一个`Symbol`，你需要记住，虽然有这些优点，如果你使用类似于`each`,`contains`这种泛滥形Symbol名称，可能还是会导致不必要的冲突后果。

还有另外一种类型的Symbol，内置的常用Symbol。

### 众多周知的Symbols

到现在为止，我们已经讨论了可以通过`Symbol`函数创建的local Symbol 和 可以通过`Symbol.for`创建的全局Symbol。我们将讲到的第三种也是最后一种Symbol就是`well-known Symbol`了。它们内置于语言中而非由JS开发者创建，它们为内置的语言行为添加了钩子，允许你拓展或者自定义这门语言里在ES6之前不能使用的一些方面。


描述在不破坏代码的情况下，如何通过Symbols 给语言添加额外的功能的最好的例子是`Symbol.toPrimitive` 符号。它可以用分配一个函数来确定一个对象如何对应到一个默认值。该函数接收一个`hint`参数，参数可以是`string`,`number`或`default`，用以指明默认值的期待类型。

```js
const morphling = {
  [Symbol.toPrimitive](hint) {
    if (hint === 'number') {
      return Infinity
    }
    if (hint === 'string') {
      return 'a lot'
    }
    return '[object Morphling]'
  }
}
console.log(+morphling)
// <- Infinity
console.log(`That is ${ morphling }!`)
// <- 'That is a lot!'
console.log(morphling + ' is powerful')
// <- '[object Morphling] is powerful'
```


另一个众所周知的symbol是`Symbol.match`,是个常规的设置`Symbol.match`为`false`的常规表达式如果被传递给`.startWith`,`.endWith`或`.includes`时将被视为字符串字面量。这三个函数是ES6提供的新的字符串方法。首先`.startsWith`用于判断某个字符串是否已另外一个字符串开头，`.endsWith`则用以判别该字符串是否已某字符串结尾，`.includes`方法则在某字符串包含另一个字符串时返回`true`。下述代码表明了`Symbol.mathc`如何用以对比一个字符串和另一个由正则表达式表示的字符串。

```js
const text = '/an example string/'
const regex = /an example string/
regex[Symbol.match] = false
console.log(text.startsWith(regex))
// <- true
```

如果正则表达式没有通过Symbol修改，这里将抛出错误，因为`.startWith`方法希望其参数是一个字符串而非正则表达式。


#### 不在注册表中但是跨域共享

语言内置的这些Symbol是跨代码域共享的，下述代码展示了`Symbol.iterator`在`<iframe>`中是具有相同的指向的。

```js
const frame = document.createElement('iframe')
document.body.appendChild(frame)
Symbol.iterator === frame.contentWindow.Symbol.iterator
// <- true
```

需要注意的是，虽然语言内置的这些Symbol是跨代码块共享的，但是他们并不在全局符号注册表中，下述代码中，我们想要找到`Symbol.iterator`的`key`值，返回值是`undefined`，这意味着符号并不在全局注册表中。

```js
console.log(Symbol.keyFor(Symbol.iterator))
// <- undefined
```

另外一个常用的符号是`Symbol.iterator`,它被不同的语言用以遍历一个序列，就像在任意对象中定义一个函数并分配给一个用符号定义的属性。下一章中，我们将详细讲述`Symbol.iterator`的细节内容，并广泛在迭代器和迭代协议中使用它。

## 内置对象的改进
















