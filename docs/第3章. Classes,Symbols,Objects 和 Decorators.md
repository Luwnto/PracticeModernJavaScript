# Classs,Symbols,Objects 和 Decorators

**本章尚未完成，请先不要编辑本章**



前面我们已经学习了ES6对JS的基本改进，是时候学习一些别的特性了--classes 和 symbols。ES6中新增的类（classes）提供了一种以原型链来模仿传统基于类编程的模式。而Symbol则是JavaScript中的一种新的基本类型（像字符串，布尔值，数值一样），它可以用来定义协议，本章中，我们将说明这是什么意思。本章说完类和`symbols`后将继续讨论一些新增如`ES6`的内置静态方法。

## Classes

JavaScript是一种基于原型链的语言，新增的类可以看做一种基于原型链的语法糖。原型继承和类之间的最大差别在于，类可以拓展其它类，这使得我们可以拓展内置的`Array`，而这用ES6之前的语法实现是很复杂的。

### 类基础

学习新知识之前，复习一下已存的结构是一个很好的主意，然后再看新特性给这些已有的结构带来了那些改进。基于此，本文将先简单复习基于原型链的JavaScript构造器，然后把它和ES6中新增的类语法做对比。

下面代码中，我们使用添加了若干方法的构造函数表示一种水果。构造函数的参数为水果的名称`name`和卡路里含量`calaries`，默认该水果只有一块`pieces=1`,`.chop`方法可以为该水果分隔另外一块，此外`.bite`方法，表示传入`.bite`方法的`person`将吃一口该水果，并使得饱腹感`satiety`等于总卡路里量减去剩余的水果块的卡路里量。

```js
function Fruit(name, calories) {
  this.name = name
  this.calories = calories
  this.pieces = 1
}
Fruit.prototype.chop = function () {
  this.pieces++
}
Fruit.prototype.bite = function (person) {
  if (this.pieces < 1) {
    return
  }
  const calories = this.calories / this.pieces
  person.satiety += calories
  this.calories -= calories
  this.pieces--
}
```

尽管上面的代码很简单，但是它们也足以让我们来记录一些事情了。这里我们有一个构造函数，这个构造函数接收一些参数，并在其中定义了一些事件，一些属性。下述代码表示我们如果创建`Fruit`的实例，一个`person`将该实例水果分隔为四块并吃了三口。

```js
const person = { satiety: 0 }
const apple = new Fruit('apple', 140)
apple.chop()
apple.chop()
apple.chop()
apple.bite(person)
apple.bite(person)
apple.bite(person)
console.log(person.satiety)
// <- 105
console.log(apple.pieces)
// <- 1
console.log(apple.calories)
// <- 35
```

如果我们使用的是Class，如下面代码所示，构造函数被声明为水果类的显式成员，方法遵循对象字面方法定义语法。如果我们把`class`语法和基于原型的语法做对比，你会发现我们的方法使用显式声明的同时大量减少了样本代码的使用即省略了`fruit.prototype`。事实上，将方法全部声明在`class`的块中也有助于读者理解，使得我们的类意图明确，将构造函数显式地作为`fruit`的方法成员，与基于原型的类语法相比也更容易理解。

```js
class Fruit {
  constructor(name, calories) {
    this.name = name
    this.calories = calories
    this.pieces = 1
  }
  chop() {
    this.pieces++
  }
  bite(person) {
    if (this.pieces < 1) {
      return
    }
    const calories = this.calories / this.pieces
    person.satiety += calories
    this.calories -= calories
    this.pieces--
  }
}
```

你可能注意到这里有一个容易被忽略的细节，我们的`Fruit`类的方法之间没有逗号，这里并不是我写错了，这是类语法的要求，这种要求帮忙我们避免了一种错误，即把普通的对象和类互换，它们其实是不一样的。同时这样做，也为未来类的改进做下铺垫，未来类中可能还会添加`public`或`private`类区域。

上述我们基于类的代码和基于原型链的代码是一样的。`Fruit`的行为一点也不会变，其API也没有变。基于类的方法中，我们实例化了apple，把它切为小块，然后吃掉了其中的大部分这些事情在基于类的`Fruit`中同样会做。

值得注意的是，类声明并不会被提升到作用域的顶部，就像函数声明和函数表达式一样，类也可以被声明为表达式，你可以像下述代码中这样，声明类名

```js
const Person = class {
  constructor(name) {
    this.name = name
  }
}
```

类可以作为函数的返回值，这使得创建类工厂非常容易，在下面的例子中我们创建一个动态的箭头的函数，它接受一个名为`name`的参数，然后通过`super()`把它反馈给其父类`Person`.

```js
const createPersonClass = name => class extends Person {
  constructor() {
    super(name)
  }
}
const JakePerson = createPersonClass('Jake')
const jake = new JakePerson()
```

我们将在稍后详细讨论类继承，在此之前我们先仔细看看属性和方法。

### 类中的属性和方法

值得我们注意的是类声明中的`constructor`方法是可选的。下面用类声明和用常规构造函数声明的`Fruit`是一样的：



```javascript
class Fruit {
}
function Fruit() {
}
```



所有被传入`Log()`的参数都将作为`Log`中`constructor`的参数，这些参数可以用以初始化类的实例。



```javascript
class Log {
  constructor(...args) {
    console.log(args)
  }
}
new Log(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)
// &amp;lt;- [&apos;a&apos; &apos;b&apos; &apos;c&apos;]
```



下面的代码则表示在创建类`Counter`类的实例时，我们会为该实例初始化一个名为`count`的属性。`get next`方法则表示类`Counter`实例将有一个`next`方法，用以返回调用调用结果。



```javascript
class Counter {
  constructor(start) {
    this.count = start
  }
  get next() {
    return this.count++
  }
}
```



你可以像下面这样使用`Counter`类，每一次`.next`被调用的时候，`count`值增加1，虽然有效，但是这种方法一般说来比使用`get`属性访问器其要好，我们需要注意，不应该乱用`get`这里属性访问器。滥用属性访问器的对象一般都会变得让人疑惑。

```javascript
const counter = new Counter(2)
console.log(counter.next)
//  2
console.log(counter.next)
//  3
console.log(counter.next)
//  4
```



当与设置器配对时，访问者可能会在对象及其底层数据存储之间提供有趣的桥梁。我们可以考虑如下例子，这里我们定义了一个类，使用提供的存储`key`，它可以用来在`localStorage`中存储和取出`JSON`数据。



```javascript
class LocalStorage {
  constructor(key) {
    this.key = key
  }
  get data() {
    return JSON.parse(localStorage.getItem(this.key))
  }
  set data(data) {
    localStorage.setItem(this.key, JSON.stringify(data))
  }
}
```



你可以按下面这样使用`LocalStorage`类。所有分配给`ls.data`的值将被转换为JSON对象字符串，并存储在`localStorage`中。然后，当需要读取时，想用的`key`将用以在之前存储的内容中读取数据，以JSON的格式进行解析，并返回。

```javascript
const ls = new LocalStorage(&apos;groceries&apos;)
ls.data = [&apos;apples&apos;, &apos;bananas&apos;, &apos;grapes&apos;]
console.log(ls.data)
// &amp;lt;- [&apos;apples&apos;, &apos;bananas&apos;, &apos;grapes&apos;]
```



除了使用`getters`和`setters`,我们也可以定义常规的实例方法，前面我们已经定义过`Fruit`类。下面我们还定义了一个可以吃水果的`Person`类，我们可以实例化一个`fruit`和一个`person`，然后让`person`吃`fruit`。最后由于这个人吃完了整个水果,`person`的`satiety`(饱食度)上升到了40。

```javascript
class Person {
  constructor() {
    this.satiety = 0
  }
  eat(fruit) {
    while (fruit.pieces &amp;gt; 0) {
      fruit.bite(this)
    }
  }
}
const plum = new Fruit(&apos;plum&apos;, 40)
const person = new Person()
person.eat(plum)
console.log(person.satiety)
// &amp;lt;- 40
```



有时候我们需要在类层面上定义静态方法而不仅仅是在实例层面上定义静态方法，如果使用的是ES6之前的语法，我们将不得不把实例成员添加到原型链中，而静态方法则被直接添加入构造函数中。

```javascript
function Person() {
  this.hunger = 100
}
Person.prototype.eat = function () {
  this.hunger--
}
Person.isPerson = function (person) {
  return person instanceof Person
}
```



就像你使用`get``set`前赘定义`getter`和`setter`一样，类允许你使用通过前缀`static`定义静态方法`Persion.isPerson`。



下属代码利用了`Array#reduce`方法在类`MathHelper`中定义了一个静态方法`sum`，这个方法将用以计算所有传入所调用函数中的参数的总和。



```javascript
class MathHelper {
  static sum(...numbers) {
    return numbers.reduce((a, b) =&amp;gt; a + b)
  }
}
console.log(MathHelper.sum(1, 2, 3, 4, 5))
// &amp;lt;- 15
```



最后，还需要说明的是你可以结合`getter`，`setter`使用类静态方法，这在维持类全局状态时或者类使用单例模式时非常有用。当然你依旧可以用老方法而不用定义一个你永远不会实例化的类或者只会实例化一次的类，这就是JavaScript，一个高度灵活的语言。



### JavaScript类的拓展

你可以使用普通的JavaScript来拓展`Fruit`类，就像下面这样，我们声明子类时用到了深奥的`Parent.call(this)`以便能将参数传递给父类，以便我们可以正确地初始化子类，并把子类的接在父类的原型中。你在网上可以找到很多关于原型继承的知识，所以我们在这里就不再赘述了。



```javascript
function Banana() {
  Fruit.call(this, &apos;banana&apos;, 105)
}
Banana.prototype = Object.create(Fruit.prototype)
Banana.prototype.slice = function () {
  this.pieces = 12
}
```



鉴于需要记住这些不常用的知识，而且`Object.create`在ES5中才能使用，一般JS开发者都使用库来解决继承问题。比如说Node.js中的`util.inherits`,由于遗留问题，它通常比`Object.create`更受欢迎。



```javascript
const util = require(&apos;util&apos;)
function Banana() {
  Fruit.call(this, &apos;banana&apos;, 105)
}
util.inherits(Banana, Fruit)
Banana.prototype.slice = function () {
  this.pieces = 12
}
```



考虑到除了banana有`name`，并已有确定的`calories`,以及有额外的`slice`方法用以把banana切为12块外，Banana构造函数和`Fruit`构造函数没有区别。下面的代码表现了我们咬(bite)的时候`Banana`的行为：

```javascript
const person = { satiety: 0 }
const banana = new Banana()
banana.slice()
banana.bite(person)
console.log(person.satiety)
// &amp;lt;- 8.75
console.log(banana.pieces)
// &amp;lt;- 11
console.log(banana.calories)
// &amp;lt;- 96.25
```



Fruit类其实是被继承了，下面的代码中，我们创建了一个Banana类用以继承Fruit类，这种语法非常清晰，我们无须彻底弄明白原型的机制就可以获得我们想要的结果。如果我们想要给`Fruit`类传递参数，我们只需要使用`super`关键字即可，`super`关键字还可以用以调用存在于父类中的方法，比如说`super.chop`,它的使用不限于在`constructor`里面。



```javascript
class Banana extends Fruit {
  constructor() {
    super(&apos;banana&apos;, 105)
  }
  slice() {
    this.pieces = 12
  }
}
```



尽管`class`关键字是静态的，我们还可以结合使用JavaScript的函数的特性和灵活性。所有返回构造函数的表达式都可以用于拓展，我们因此可以有一个构造函数工厂，并它当做基类。



下面的代码中定义了一个`createJuicyFruit` 的函数，通过使用`super`我们可以给`Fruit`类传入`name`和`calories`,之后所有我们需要做的事情就是拓展`JuicyFruit` 类了。



```javascript
const createJuicyFruit = (...params) =>
  class JuicyFruit extends Fruit {
    constructor() {
      this.juice = 0
      super(...params)
    }
    squeeze() {
      if (this.calories <= 0) {
        return
      }
      this.calories -= 10
      this.juice += 3
    }
  }
class Plum extends createJuicyFruit('plum', 30) {
}
```



接下来我们来先讲述`Symbol`,了解`Symbol`对于之后我们理解迭代至关重要，这将在本章后面进行讨论。



## Symbols

Symbol是ES6提供的一种新的JavaScript的基本类型。 它代表唯一值，和字符串，数值不同的是，Symbol并没有字符的表达形式，如`text`字符串，或 `1`数值。Symbol的主要目的是用以实现协议，比如说，迭代协议使用Symbol定义对象如何被迭代，我们将在[Iterator Protocol and Iterable Protocol.]()这一节详细阐述。

有三种不同蕾西的Symbol，每一种有不同的使用方法，它们分别是
- `local Symbol`，这种类型又内置的Symbol包装对象创建，通过反射或者存储引用来使用。
- `global Symbol`,由另外一个API创建 并且全局可用；
- `well-konwn Symbol`,内置于JavaScript，用于定义内部语言行为。

我们将讨论全部这三种，看看它们分别该怎么使用，从`local Symbol`说起吧。

### Local Symbol

Symbols 可通过 `Symbol` 包装对象创建，下例中，我们创建了我们的第一个Symbol。

```js
const first = Symbol()
```

尽管你可以在`Number`或`String`前使用`new`操作符，在`Symbol`前却不能使用，否则会抛出错误，这避免了错误和注入`new Number(3) !== Number(3)`这样令人误解的行为，下述代码表现了报错是什么样的：

```js
const oops = new Symbol()
// <- TypeError, Symbol is not a constructor
```

为了调试遍历，新建的`Symbol`可以添加描述：

```js
const mystery = Symbol('my symbol')
```

和数值和字符串一样，Symbol是不可变的，但是和这些类型不同的是，Symbol是唯一的。下面代码中，描述并不影响唯一性，由相同描述创建的Symbol依旧是唯一且不相等的。

```js
console.log(Number(3) === Number(3))
// <- true
console.log(Symbol() === Symbol())
// <- false
console.log(Symbol('my symbol') === Symbol('my symbol'))
// <- false
```

Symbols的类别为`symbol`，下述代码显示了对Symbol 使用 `typeof`返回的值：

```js
console.log(typeof Symbol())
// <- 'symbol'
console.log(typeof Symbol('my symbol'))
// <- 'symbol'
```

Symbols 可以用作对象的属性名，这里我们用计算属性名来说明如何使用，如下所示，为了使用一个Symbol属性，您需要引用用于创建所述属性的Symbol。

```js
const weapon = Symbol('weapon')
const character = {
  name: 'Penguin',
  [weapon]: 'umbrella'
}
console.log(character[weapon])
// <- 'umbrella'
```

需要注意的是，许多传统的从对象中提取键的方法中对Symbol无效。下述代码表明`for...in `,`Object,keys`,`Object.getOwnPropertyNames`都不能访问到Symbol 属性。

```js
for (let key in character) {
  console.log(key)
  // <- 'name'
}
console.log(Object.keys(character))
// <- ['name']
console.log(Object.getOwnPropertyNames(character))
// <- ['name']
```

Symbol的这方面的特性表明，ES6之前的没有Symbol的代码并不会由于Symbol的出现而受影响。类似的，如下代码所示，当将对象解析为JSON时，符号属性将被丢弃。

```js
console.log(JSON.stringify(character))
// <- '{"name":"Penguin"}'
```

这意味着，Symbols绝不是隐藏属性的安全机制。即使在使用反射或序列化方法时不会发现符号属性，符号也会由专用方法揭示，如下一段代码所示。这意味着，Symbols 并非不可枚举的，只是一般情况下它不可见而已，通过`Object.getOwnPropertySymbols`我们可以获取任何对象中的所有`Symbol`.

```js
console.log(Object.getOwnPropertySymbols(character))
// <- [Symbol(weapon)]
```

现在我们已经知道了Symbol该如何使用，下面我们谈谈它该在什么时候使用？

### Symbols的使用案例

Symbols可以通过库来使用，用于将对象映射到DOM元素，比如说，一个库需要连接日历的API对象和所提供的DOM元素。ES6之前，并不存在一种清晰的方法可用用以建立DOM和对象之间的映射。你可以给DOM元素添加一个属性指向API，但是这回用自定义属性污染DOM元素，这并不是一种好的实践方法。您必须小心地使用不被其他库使用的属性键，或者更糟糕的是，将来语言本身将使用的属性。这就让您使用一个数组查找表，该表为每个DOM / API对包含一个条目。然后，在一个长期运行的程序中，随着数组查找表越来越大，慢慢的查找操作就越来越慢了。

使用Symbol则完全没有这类问题了，你不用担心定义的属性名会和将来语言中的属性名冲突，它们是唯一的。下述代码表明了如何使用Symbol建立DOM和日历API之间的映射。

```js
const cache = Symbol('calendar')
function createCalendar(el) {
  if (cache in el) { // does the symbol exist in the element?
    return el[cache] // use the cache to avoid re-instantiation
  }
  const api = el[cache] = {
    // the calendar API goes here
  }
  return api
}
```

ES6 提供的一种新数据类型`WeakMap`,它可以用于唯一地将对象映射到其他对象，而不需要使用数组或将外部属性放置在我们希望查找的对象上。和数组查找表比起来，`WeakMap`查找复杂度始终为O(1),我们将在[ Leveraging ECMAScript Collections]()一节和其它ES6内置对象详细讨论`WeakMap`。

### 通过符号定义协议

早些时候，我们假设`Symbol`用以定义协议。协议是定义行为的通信契约或约定。简单说来，库可用使用Symbol ,然后我们可以使用从库中继承约定的对象。











