# Classs,Symbols,Objects拓展 和 Decorators

**本章尚未完成，请先不要编辑本章**

ES6中新增的类（`classes`) 提供了一种以原型链来模仿传统上基于类编程的模式。而新增的符号`Symbol`则是一种新的基本类型（JS中的第七种基本类型，另外六种为`undefined`、`null`、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）），它可以用来定义不可变值。本章中，我们将首先讨论类和符号，之后我们还将对对象的拓展及装饰器进行简单的讲解。

## 类

我们知道，JavaScript是一种基于原型链的语言，ES6中新增的类和其它面向对象语言中的类有很大的不同，JS中，类实际上是一种基于原型链的语法糖。类可以用以拓展其它类，比如说，我们可以通过简单的语法拓展内置的`Array`，而如果用ES6之前的语法实现，会复杂很多。

### 类的基础

基于已有的知识学习新知识是一种非常好的学习方法，这样我们会对新特性给我们带来的便利性感触更深。基于JS中类实际上是一种基于原型链的语法糖，我们先简单复习基于原型链的JavaScript构造器该怎么使用，然后我们用ES6中类语法实现作为对比。

下面代码中，我们构建了构造函数`Fruit`用以表示水果的特征。构造函数接收两个参数，水果的名称--`name`，水果的卡路里含量--`calaries`。我们在`Fruit`构造函数中设置了默认的块数 `pieces=1`,该构造函数的 `chop` 方法表示切水果的行为，每次调用会使得块数加一，`bite`方法接收一个名为`person`的参数，它是一个对象，每次调用，该 `person` 将吃掉一块水果，`person` 的饱腹感 `person.satiety ` 将相应的增加，增加值为一块水果的`calaries`值，水果的总的卡路里值 `this.calories`将减少相应的值。

```js
function Fruit(name, calories) {
  this.name = name
  this.calories = calories
  this.pieces = 1
}
Fruit.prototype.chop = function () {
  this.pieces++
}
Fruit.prototype.bite = function (person) {
  if (this.pieces < 1) {
    return
  }
  const calories = this.calories / this.pieces
  person.satiety += calories
  this.calories -= calories
  this.pieces--
}
```

下面我们如果创建一个`Fruit`构造函数的实例，调用三次`chop`将实例`apple`分为四块，新建`person`对象，传入并调用三次`bite`方法，把`apple`吃掉三块。

```js
const person = { satiety: 0 }
const apple = new Fruit('apple', 140)
apple.chop()
apple.chop()
apple.chop()
apple.bite(person)
apple.bite(person)
apple.bite(person)
console.log(person.satiety)
// <- 105
console.log(apple.pieces)
// <- 1
console.log(apple.calories)
// <- 35
```

作为对比，下面我们使用类来做和上面一样的事情，在类中，我们显式使用`constructor`方法做为构造方法（其中`this`指向类的实例），在类中定义方法类似在对象字面量中定义方法如`chop`,`bite`。对比基于类和基于原型链的语法，我们会看出，类的所有的方法都声明在`class`的块中，不需要再使用`Fruit.prototype`这类样本代码，与基于原型的语法比起来，类看起来更加清晰易懂。

```js
class Fruit {
  constructor(name, calories) {
    this.name = name
    this.calories = calories
    this.pieces = 1
  }
  chop() {
    this.pieces++
  }
  bite(person) {
    if (this.pieces < 1) {
      return
    }
    const calories = this.calories / this.pieces
    person.satiety += calories
    this.calories -= calories
    this.pieces--
  }
}
```

在类中定义方法和使用对象字面量类似，但是一个很大的不同在于**方法之间不能使用逗号**，这是类语法的要求。这种语法要求帮我们避免了混用普通的对象和类的错误，类和对象其实是不一样的。这种要求的另外一个好处在于为未来类的改进做下了铺垫，未来JS的类中可能还会添加`public`或`private`等，这和对象差别就更大了。

实际上，上述我们基于类的代码和基于原型链的代码是一样的。两种`Fruit`都可以吃，都可以切小块。

对了，忘了说了，类声明并不会被提升到作用域的顶部，此外像函数声明和函数表达式一样，类也可以被声明为表达式，你可以像下述代码中这样，声明类名：

```js
const Person = class {
  constructor(name) {
    this.name = name
  }
}
```

类还可以作为函数的返回值，这使得创建类工厂非常容易，如下例所示，代码中的箭头函数接收了一个名为`name`的参数，通过`super()`方法把这个参数反馈给其父类`Person`.这样就创建了一个基于`Person`的新类：

```js
// 类声明的第二种方法，Name = class{},另外一种方法为class Name {}
const createPersonClass = name => class extends Person {
  constructor() {
    super(name)
  }
}
const JakePerson = createPersonClass('Jake')
const jake = new JakePerson()
```

我们将在稍后详细讨论类继承，在此之前我们先仔细看看属性和方法。

### 类中的属性和方法

类声明中的`constructor`方法是可选的。下面用类声明和用常规构造函数声明的`Fruit`是一样的：

```javascript
// 用类声明Fruit
class Fruit {
}

// 使用构造函数声明Fruit
function Fruit() {
}
```

所有传入`Log()`的参数都将作为`Log`中`constructor`的参数，这些参数将用以初始化类的实例：

```javascript
class Log {
  constructor(...args) {
    console.log(args)
  }
}
new Log('a', 'b', 'c')
// <- ['a' 'b' 'c']
```

下面的代码中，我们定义了类`Counter`，在`constructor`中定义的代码会在实例化类时自动执行，这里我们在实例化时为实例添加了一个`count`属性，`get next`方法则表示所有类`Counter`实例都将有一个`next`方法，用以返回调用该方法的调用次数+`start`的值：


```javascript
class Counter {
  constructor(start) {
    this.count = start
  }
  get next() {
    return this.count++
  }
}
```

下面我们新建了`Counter`类的实例`counter`，之后每一次`counter`的`.next`被调用的时候，`count`值增加1，我们需要注意，不应该乱用`get`这里属性访问器。滥用属性访问器的对象一般都会变得让人疑惑。

```javascript
const counter = new Counter(2)
console.log(counter.next)
//  2
console.log(counter.next)
//  3
console.log(counter.next)
//  4
```

> get 语法将一个对象属性绑定到查询该属性时将被调用的一个函数上。访问属性时能返回一个动态计算后的值, 或希望不通过使用明确的方法调用而显示内部变量的状态.在JavaScript中, 能通过使用 getter 实现；
> set 语法绑定一个属性，其后跟着一个函数，当为该函数设置为某个值时，其后的函数将被调用；

当结合使用`getter`和`setter`时，我们可以完成一些神奇的事情，如下例中，我们定义了一个类`LocalStorage`，使用提供的存储`key`，可以在读取`data`值时，同时使它在`localStorage`中存储和取出相关数据。

```javascript
class LocalStorage {
  constructor(key) {
    this.key = key
  }
  get data() {
    return JSON.parse(localStorage.getItem(this.key))
  }
  set data(data) {
    localStorage.setItem(this.key, JSON.stringify(data))
  }
}
```

我们看看如何使用`LocalStorage`类。首先我们新建`LocalStorage`的实例`ls`,传入该实例的`key`为`groceries`,当我们设置`ls.data`为某个值时，该值将被转换为JSON对象字符串，并存储在`localStorage`中，当需要读取时，我们将使用相应的`key`，提取出之前存储在`localStorage`中的内容，以JSON的格式进行解析后返回：

```javascript
const ls = new LocalStorage('groceries')
ls.data = ['apples', 'bananas', 'grapes']
console.log(ls.data)
// <- ['apples', 'bananas', 'grapes']
```

除了使用`getters`和`setters`,我们也可以定义常规的实例方法，前面我们已经定义过`Fruit`类。下面我们再定义了一个可以吃水果的`Person`类，接下来我们实例化一个`fruit`和一个`person`，然后让 `person` 吃 `fruit` 。之后我们让`person`吃完了所有的`fruit`，随之`person`的`satiety`(饱食度)上升到了40。

```javascript
class Person {
  constructor() {
    this.satiety = 0
  }
  eat(fruit) {
    while (fruit.pieces > 0) {
      fruit.bite(this)
    }
  }
}
const plum = new Fruit('plum', 40)
const person = new Person()
person.eat(plum)
console.log(person.satiety)
// <- 40
```

有时候我们可能会希望静态方法直接定义在类上，使用的是ES6之前的语法，我们需要将该方法直接添加于构造函数上，如下面的`Person.isPerson`:

```javascript
function Person() {
  this.hunger = 100
}
Person.prototype.eat = function () {
  this.hunger--
}
Person.isPerson = function (person) {
  return person instanceof Person
}
```

类语法则允许你，通过添加前缀`static`来定义静态方法`Persion.isPerson`，

下属代码我们给类`MathHelper`中定义了一个静态方法`sum`，这个方法将用以计算实例化时所有传入参数的总和。

```javascript
class MathHelper {
  static sum(...numbers) {
    return numbers.reduce((a, b) => a + b)
  }
}
console.log(MathHelper.sum(1, 2, 3, 4, 5))
// <- 15
```

不过具体怎么用都取决于你的偏好，JavaScript就是这么一门非常灵活的语言，你怎么用都行。

### JavaScript类的拓展

你可以使用普通的JavaScript来拓展`Fruit`类，就像下面这样，我们声明子类时用到了深奥的`Parent.call(this)`以便能将参数传递给父类，以便我们可以正确地初始化子类，并把子类的接在父类的原型中。你在网上可以找到很多关于原型继承的知识，所以我们在这里就不再赘述了。



```javascript
function Banana() {
  Fruit.call(this, 'banana', 105)
}
Banana.prototype = Object.create(Fruit.prototype)
Banana.prototype.slice = function () {
  this.pieces = 12
}
```



鉴于需要记住这些不常用的知识，而且`Object.create`在ES5中才能使用，一般JS开发者都使用库来解决继承问题。比如说Node.js中的`util.inherits`,由于遗留问题，它通常比`Object.create`更受欢迎。



```javascript
const util = require('util')
function Banana() {
  Fruit.call(this, 'banana', 105)
}
util.inherits(Banana, Fruit)
Banana.prototype.slice = function () {
  this.pieces = 12
}
```



考虑到除了banana有`name`，并已有确定的`calories`,以及有额外的`slice`方法用以把banana切为12块外，Banana构造函数和`Fruit`构造函数没有区别。下面的代码表现了我们咬(bite)的时候`Banana`的行为：

```javascript
const person = { satiety: 0 }
const banana = new Banana()
banana.slice()
banana.bite(person)
console.log(person.satiety)
// <- 8.75
console.log(banana.pieces)
// <- 11
console.log(banana.calories)
// <- 96.25
```



Fruit类其实是被继承了，下面的代码中，我们创建了一个Banana类用以继承Fruit类，这种语法非常清晰，我们无须彻底弄明白原型的机制就可以获得我们想要的结果。如果我们想要给`Fruit`类传递参数，我们只需要使用`super`关键字即可，`super`关键字还可以用以调用存在于父类中的方法，比如说`super.chop`,它的使用不限于在`constructor`里面。



```javascript
class Banana extends Fruit {
  constructor() {
    super('banana', 105)
  }
  slice() {
    this.pieces = 12
  }
}
```



尽管`class`关键字是静态的，我们还可以结合使用JavaScript的函数的特性和灵活性。所有返回构造函数的表达式都可以用于拓展，我们因此可以有一个构造函数工厂，并它当做基类。



下面的代码中定义了一个`createJuicyFruit` 的函数，通过使用`super`我们可以给`Fruit`类传入`name`和`calories`,之后所有我们需要做的事情就是拓展`JuicyFruit` 类了。



```javascript
const createJuicyFruit = (...params) =>
  class JuicyFruit extends Fruit {
    constructor() {
      this.juice = 0
      super(...params)
    }
    squeeze() {
      if (this.calories <= 0) {
        return
      }
      this.calories -= 10
      this.juice += 3
    }
  }
class Plum extends createJuicyFruit('plum', 30) {
}
```



接下来我们来先讲述`Symbol`,了解`Symbol`对于之后我们理解迭代至关重要，这将在本章后面进行讨论。



## Symbols

Symbol是ES6提供的一种新的JavaScript的基本类型。 它代表唯一值，和字符串，数值不同的是，Symbol并没有字符的表达形式，如`text`字符串，或 `1`数值。Symbol的主要目的是用以实现协议，比如说，迭代协议使用Symbol定义对象如何被迭代，我们将在[Iterator Protocol and Iterable Protocol.]()这一节详细阐述。

有三种不同蕾西的Symbol，每一种有不同的使用方法，它们分别是
- `local Symbol`，这种类型又内置的Symbol包装对象创建，通过反射或者存储引用来使用。
- `global Symbol`,由另外一个API创建 并且全局可用；
- `well-konwn Symbol`,内置于JavaScript，用于定义内部语言行为。

我们将讨论全部这三种，看看它们分别该怎么使用，从`local Symbol`说起吧。

### Local Symbol

Symbols 可通过 `Symbol` 包装对象创建，下例中，我们创建了我们的第一个Symbol。

```js
const first = Symbol()
```

尽管你可以在`Number`或`String`前使用`new`操作符，在`Symbol`前却不能使用，否则会抛出错误，这避免了错误和注入`new Number(3) !== Number(3)`这样令人误解的行为，下述代码表现了报错是什么样的：

```js
const oops = new Symbol()
// <- TypeError, Symbol is not a constructor
```

为了调试遍历，新建的`Symbol`可以添加描述：

```js
const mystery = Symbol('my symbol')
```

和数值和字符串一样，Symbol是不可变的，但是和这些类型不同的是，Symbol是唯一的。下面代码中，描述并不影响唯一性，由相同描述创建的Symbol依旧是唯一且不相等的。

```js
console.log(Number(3) === Number(3))
// <- true
console.log(Symbol() === Symbol())
// <- false
console.log(Symbol('my symbol') === Symbol('my symbol'))
// <- false
```

Symbols的类别为`symbol`，下述代码显示了对Symbol 使用 `typeof`返回的值：

```js
console.log(typeof Symbol())
// <- 'symbol'
console.log(typeof Symbol('my symbol'))
// <- 'symbol'
```

Symbols 可以用作对象的属性名，这里我们用计算属性名来说明如何使用，如下所示，为了使用一个Symbol属性，您需要引用用于创建所述属性的Symbol。

```js
const weapon = Symbol('weapon')
const character = {
  name: 'Penguin',
  [weapon]: 'umbrella'
}
console.log(character[weapon])
// <- 'umbrella'
```

需要注意的是，许多传统的从对象中提取键的方法中对Symbol无效。下述代码表明`for...in `,`Object,keys`,`Object.getOwnPropertyNames`都不能访问到Symbol 属性。

```js
for (let key in character) {
  console.log(key)
  // <- 'name'
}
console.log(Object.keys(character))
// <- ['name']
console.log(Object.getOwnPropertyNames(character))
// <- ['name']
```

Symbol的这方面的特性表明，ES6之前的没有Symbol的代码并不会由于Symbol的出现而受影响。类似的，如下代码所示，当将对象解析为JSON时，符号属性将被丢弃。

```js
console.log(JSON.stringify(character))
// <- '{"name":"Penguin"}'
```

这意味着，Symbols绝不是隐藏属性的安全机制。即使在使用反射或序列化方法时不会发现符号属性，符号也会由专用方法揭示，如下一段代码所示。这意味着，Symbols 并非不可枚举的，只是一般情况下它不可见而已，通过`Object.getOwnPropertySymbols`我们可以获取任何对象中的所有`Symbol`.

```js
console.log(Object.getOwnPropertySymbols(character))
// <- [Symbol(weapon)]
```

现在我们已经知道了Symbol该如何使用，下面我们谈谈它该在什么时候使用？

### Symbols的使用案例

Symbols可以通过库来使用，用于将对象映射到DOM元素，比如说，一个库需要连接日历的API对象和所提供的DOM元素。ES6之前，并不存在一种清晰的方法可用用以建立DOM和对象之间的映射。你可以给DOM元素添加一个属性指向API，但是这回用自定义属性污染DOM元素，这并不是一种好的实践方法。您必须小心地使用不被其他库使用的属性键，或者更糟糕的是，将来语言本身将使用的属性。这就让您使用一个数组查找表，该表为每个DOM / API对包含一个条目。然后，在一个长期运行的程序中，随着数组查找表越来越大，慢慢的查找操作就越来越慢了。

使用Symbol则完全没有这类问题了，你不用担心定义的属性名会和将来语言中的属性名冲突，它们是唯一的。下述代码表明了如何使用Symbol建立DOM和日历API之间的映射。

```js
const cache = Symbol('calendar')
function createCalendar(el) {
  if (cache in el) { // does the symbol exist in the element?
    return el[cache] // use the cache to avoid re-instantiation
  }
  const api = el[cache] = {
    // the calendar API goes here
  }
  return api
}
```

ES6 提供的一种新数据类型`WeakMap`,它可以用于唯一地将对象映射到其他对象，而不需要使用数组或将外部属性放置在我们希望查找的对象上。和数组查找表比起来，`WeakMap`查找复杂度始终为O(1),我们将在[ Leveraging ECMAScript Collections]()一节和其它ES6内置对象详细讨论`WeakMap`。

### 通过符号定义协议

早些时候，我们假设`Symbol`用以定义协议。协议是定义行为的通信契约或约定。简单说来，库可用使用Symbol ,然后依附于该库的对象就可以使用Symbol了。

考虑下面的代码，这里我们用了一个特殊的`toJSON`方法，用以限制可以被`JSON.stringify`序列化的对象。正如你所看到的，序列化`character`对象返回了`toJSON`方法返回的对象的序列化模式。


```js
const character = {
  name: 'Thor',
  toJSON: () => ({
    key: 'value'
  })
}
console.log(JSON.stringify(character))
// <- '"{"key":"value"}"'
```

相比之下，如果`toJSON`不是一个函数，原始的`character`对象将被序列化，`toJSON`只是其中一个属性，就像下面代码中那样。出现这种不一致的原因在于使用了常规属性来定义行为。

```js
const character = {
  name: 'Thor',
  toJSON: true
}
console.log(JSON.stringify(character))
// <- '"{"name":"Thor","toJSON":true}"'
```

让`toJSON`修饰符是一个Symbol则更好，原因是它不会影响其它的对象属性，考虑到symbols 是唯一的，永远不会被序列化的，不调用`Object.getOwnPropertySymbols`永远不会暴露出来的，当制定一个`JSON.stringify`和对象如何被序列化的协议时，使用Symbol将是一种更好的选择。以下代码表明了如何使用Symbol定义`stringify`函数的序列化行为。

```js
const json = Symbol('alternative to toJSON')
const character = {
  name: 'Thor',
  [json]: () => ({
    key: 'value'
  })
}
stringify(character)
function stringify(target) {
  if (json in target) {
    return JSON.stringify(target[json]())
  }
  return JSON.stringify(target)
}
```

使用Symbol 意味着我们需要使用计算属性名来在对象字面量中直接定义`json`的行为。它同样意味着，这种行为不会和其它的用户定义属性或者以后JS语言可能会加入的属性有冲突。另一个不同的地方在于，用户通过`stringify `函数是可以使用`json`符号的，因此它们可以自定义行为，我们可以通过下面的代码通过`stringify`暴露`json`符号，如下所示，这将绑定`stringify`函数和修改其行为的符号。

```js
stringify.as = json
```

通过暴露`stringify`函数，我们可以使用`stringify.as`符号了，这就让使用者可以通过自定义的符号来调整对象的行为了。

当谈到使用使用符号来描述行为的优点时，与传递给`stringify`函数一个选项成对比的是，我们还需要考虑以下几点。首先，给函数添加选项参数改变了它的公有API，而改变一个函数的内在行为来支持另外一个符号不会影响公有API。使用每一个选项包含不同对象的`object`对象缓和了这一影响，不过在每一个函数调用中要求一个`options`对象并不总是很方便。

通过符号定义行为的优点是你可以增强或自定义对象的行为而不影响除了所分配的符号值之外的所有东西，原始的内部实现机制很可能也不会受影响。使用符号的好久就在于，当引入新的语言特性时，您不会受到名称冲突的影响。

除了local Symbol，还有一种`global symbol`它可以跨代码域访问，且听我细细道来。

### 全局符号

代码域指的是任何JavaScript表达式的执行上下文，比如说你的应用当前运行的页面，页面中的`<iframe>`，`eval`运行的脚本，以及任意类型的`worker`，比如说`web worker`,`service workers`或者`shared workers`,这些执行上下文每一种都有其全局对象比如说页面的全局对象`window`不能被`ServiceWorker`使用。与此不同的是，全局符号可以被任何代码域访问。

有两种和运行时的全局符号交互的方法，它们是`Symbol.for`和`Symbol.keyFor`。我们看看它们分别如何使用？

#### 通过`Symbol.for(key)`获取symbols

`Symbol.for(key)`方法将在运行时范围符号注册表中查找`key`,如果全局注册表中存在`key`则返回该`Symbol`，如果不存在该`key`的Symbol，在全局注册表中将创建以该`key`代表的Symbol，这意味着，`Symbol.for(key)`是幂等的，它先查找，不存在就创建，然后返回查找或新创建的Symbol。

下面的代码中，第一次调用`Symbol.for`创建了一个标记为`example`的Symbol，并把它添加到注册表，并返回该Symbol，第二次调用`Symbol.for`由于该`key`已经在注册表中存在，返回了相同的符号，与第一次的返回值相同。

```js
const example = Symbol.for('example')
console.log(example === Symbol.for('example'))
// <- true
```

全局的符号注册表通过`key`跟踪符号，需要注意的是`key`也将用做新创建的Symbol的`description`。考虑到这些符号在运行时是全局的，你可能需要在符号keys之前添加前缀用以区分你的逐渐或者库，用以避免潜在的命名冲突。

#### 使用`Symbol.keyFor(symbol)`来提取符号的keys

比如说现在存在一个符号`symbol`，`Symbol.keyFor(symbol)`将返回全局注册表中该`symbol`对应的`key`值。下面的例子表明了我们如何使用`Symbol.keyFor`来获取对应`Symbol`的`key`:

```js
const example = Symbol.for('example')
console.log(Symbol.keyFor(example))
// <- 'example'
```

请注意，如果该`symbol`不在全局运行注册表中，该方法将返回`undefined`。

```js
console.log(Symbol.keyFor(Symbol()))
// <- undefined
```

同样需要注意的是在全局符号注册表中不可能用`local Symbol`匹配到值，即使它们的描述相同也是如此，这是因为，local Symbol 不是全局符号注册表的一部分，如下代码所示：

```js
const example = Symbol.for('example')
console.log(Symbol.keyFor(Symbol('example')))
// <- undefined
```

现在你已经知道了全局符号注册表的两种用法，下面我们来看看还有那些别的值得考虑的因素。


#### 最佳实践和需要考虑的因素

全局的运行注册表意味着符号可以被任何代码域获取，在任何代码域中调用，全局的注册表都将返回相同的对象指向。下面的例子中，我们展示了`Symbol.for`是如何在一个页面和一个`<iframe>`中返回相同的Symbol的。

```js
const d = document
const frame = d.body.appendChild(d.createElement('iframe'))
const framed = frame.contentWindow
const s1 = window.Symbol.for('example')
const s2 = framed.Symbol.for('example')
console.log(s1 === s2)
// <- true
```

使用全局符号需要权衡，一方面，它使得库可以容易的对外暴露其Symbol，另一方面，它们也可以使用`local Symbol`暴露他们的API，很明显，符号注册表在符号需要夸代码域使用时非常有用，比如说跨`ServiceWorker`和浏览器页面。当你不想使用引用而直接想直接使用`Symbol`时，全局符号也非常方便，你可以直接调用，因为一个`key`永远对应的都是同一个`Symbol`，你需要记住，虽然有这些优点，如果你使用类似于`each`,`contains`这种泛滥形Symbol名称，可能还是会导致不必要的冲突后果。

还有另外一种类型的Symbol，内置的常用Symbol。

### 众多周知的Symbols

到现在为止，我们已经讨论了可以通过`Symbol`函数创建的local Symbol 和 可以通过`Symbol.for`创建的全局Symbol。我们将讲到的第三种也是最后一种Symbol就是`well-known Symbol`了。它们内置于语言中而非由JS开发者创建，它们为内置的语言行为添加了钩子，允许你拓展或者自定义这门语言里在ES6之前不能使用的一些方面。


描述在不破坏代码的情况下，如何通过Symbols 给语言添加额外的功能的最好的例子是`Symbol.toPrimitive` 符号。它可以用分配一个函数来确定一个对象如何对应到一个默认值。该函数接收一个`hint`参数，参数可以是`string`,`number`或`default`，用以指明默认值的期待类型。

```js
const morphling = {
  [Symbol.toPrimitive](hint) {
    if (hint === 'number') {
      return Infinity
    }
    if (hint === 'string') {
      return 'a lot'
    }
    return '[object Morphling]'
  }
}
console.log(+morphling)
// <- Infinity
console.log(`That is ${ morphling }!`)
// <- 'That is a lot!'
console.log(morphling + ' is powerful')
// <- '[object Morphling] is powerful'
```


另一个众所周知的symbol是`Symbol.match`,是个常规的设置`Symbol.match`为`false`的常规表达式如果被传递给`.startWith`,`.endWith`或`.includes`时将被视为字符串字面量。这三个函数是ES6提供的新的字符串方法。首先`.startsWith`用于判断某个字符串是否已另外一个字符串开头，`.endsWith`则用以判别该字符串是否已某字符串结尾，`.includes`方法则在某字符串包含另一个字符串时返回`true`。下述代码表明了`Symbol.mathc`如何用以对比一个字符串和另一个由正则表达式表示的字符串。

```js
const text = '/an example string/'
const regex = /an example string/
regex[Symbol.match] = false
console.log(text.startsWith(regex))
// <- true
```

如果正则表达式没有通过Symbol修改，这里将抛出错误，因为`.startWith`方法希望其参数是一个字符串而非正则表达式。


#### 不在注册表中但是跨域共享

语言内置的这些Symbol是跨代码域共享的，下述代码展示了`Symbol.iterator`在`<iframe>`中是具有相同的指向的。

```js
const frame = document.createElement('iframe')
document.body.appendChild(frame)
Symbol.iterator === frame.contentWindow.Symbol.iterator
// <- true
```

需要注意的是，虽然语言内置的这些Symbol是跨代码块共享的，但是他们并不在全局符号注册表中，下述代码中，我们想要找到`Symbol.iterator`的`key`值，返回值是`undefined`，这意味着符号并不在全局注册表中。

```js
console.log(Symbol.keyFor(Symbol.iterator))
// <- undefined
```

另外一个常用的符号是`Symbol.iterator`,它被不同的语言用以遍历一个序列，就像在任意对象中定义一个函数并分配给一个用符号定义的属性。下一章中，我们将详细讲述`Symbol.iterator`的细节内容，并广泛在迭代器和迭代协议中使用它。

## 内置对象的改进

我们在[ES6 Essentials]()一章，已经讲述过对象字面量语法的改进，关于对象一些内置的静态方法的改进我们却还未涉及到。是时候讨论一下有哪些新改变了。

前面我们说过`Object.getOwnPropertySymbols`的意思，下面我们看看`Object.assign`,`Object.is`以及`Object.setPrototypeOf`分别是什么意思。

### 使用`Object.assign`来拓展对象

需要给配置对象提供默认值的需求我们都非常熟悉，一般说来，库或者设计良好的交互组件都有明智的默认值用以应对大多数使用情况。

以一个Markdown库来说，可能会仅仅通过一个`input`参数转行Markdown为Html。这就是它最典型的使用示例，简单的解析Markdown，因此该库不需要用户提供任何选项。然后，该库可能支持很多不同的用以修改渲染行为的选项，比如说有一个选项运行`<script>`或`<iframe>`标签，或者一个选项用css来高亮渲染代码片段。

比如说，设想，你希望提供一组如下的默认选项

```js
const defaults = {
  scripts: false,
  iframes: false,
  highlightSyntax: true
}
```

一个人可能使用解构将`defaults`对象作为`options`为默认配置参数，在本例中，如果用户想要自定义，用户必须提供每个选项的值。

```js
function md(input, options=defaults) {
}
```

我们需要用某种方法将默认值和用户提供的值合并使用，这就是`Object.assign`的使用场景了，如下代码所示，我们从一个空对象`{}`开始，`Object.assign`将修改它最终返回最后的结果，实现过程是这样的，我们首先复制默认值，然后复制新添加的option到覆盖重复值，因此，最终的结果`config`对象将会是包含默认值和用户自定义值的对象。

```js
function md(input, options) {
  const config = Object.assign({}, defaults, options)
}
```


> ####理解`Object.assign`的目标

> `Object.assign`函数将改变它的第一个参数，它的签字将是`(target, ...sources)`,所有的资源 都会被应用到`target`上，一个个的source一个个的property。


> 考虑如下的场景，如果我们没有传递一个空对象作为目标对象而是传递了`defaults`作为目标对象，那么`Object.assign()`将改变`defaults`对象的值，这会导致默认值的丢失，获得一些错误的值，在复制对象的过程中，虽然这样会得到和前面那个例子中一样的值，我们的默认值也被更改了，这改变了`md`调用时的结果。

>
```js
function md(input, options) {
  const config = Object.assign(defaults, options)
}
```

> 考虑到这个原因，最好每次都给target传递一个新的空对象。


对于任何拥有默认值，用户又可以重新分配属性值的属性，用户提供的值将占主导地位。`Object.assign`是这样工作的，首先我们取得第一个传递给它的参数，我们称之为`target`，然后遍历所有其它的参数，（我们把其它的参数称为`source`）。对于`sources`中的每一个source，它的没一个值都将被迭代并分配给`target`.结果是，最右边的`sources`，在本例中也就是`options`对象，将覆盖重写前面的分配值，过程如下述代码所示：

```js
const defaults = {
  first: 'first',
  second: 'second'
}
function applyDefaults(options) {
  return Object.assign({}, defaults, options)
}
applyDefaults()
// <- { first: 'first', second: 'second' }
applyDefaults({ third: 3 })
// <- { first: 'first', second: 'second', third: 3 }
applyDefaults({ second: false })
// <- { first: 'first', second: false }
```

在语言内置`Object.assign`之前，开发者已经进行了很多类似的实践，使用类类似`assign`或者`extend`这样的名字。添加`Object.assign`到语言中使得这个需求用起来非常简单。

需要注意的是，`Object.assign`只考虑可枚举的属性，包括字符串属性和符号属性。

```js
const defaults = {
  [Symbol('currency')]: 'USD'
}
const options = {
  price: '0.99'
}
Object.defineProperty(options, 'name', {
  value: 'Espresso Shot',
  enumerable: false
})
console.log(Object.assign({}, defaults, options))
// <- { [Symbol('currency')]: 'USD', price: '0.99' }
```

需要注意的是`Object.assign`也不是万能的，比如说很多需要需要深复制的能力，`Object.assign`不会对对象进行回归处理，值为对象的将会被`target`直接引用，而不会进行每一项的递归复制。

下例中，你可能希望`f`属性可以被添加到`target.a`，而保持`b.c`,`b.d`不变，但是实际上，当使用`Object.assign`时，`b.c`和`b.d`属性丢失了。

```js
Object.assign({}, { a: { b: 'c', d: 'e' } }, { a: { f: 'g' } })
// <- { a: { f: 'g' } }
```

同样的，数组也不会获取任何特殊的对待，以下代码中，如果你期待`Object.assign`进行递归处理，你将大失所望。下面的代码中，你可以期待结果中是有`d`的。

```js
Object.assign({}, { a: ['b', 'c', 'd'] }, { a: ['e', 'f'] })
// <- { a: ['e', 'f'] }
```

在本书写作过程中，存在一个处于`stage 3`的ECMAScript提议，用以在对象中使用拓展符，就像之前提到的你可以在ES6的数组等可迭代对象中使用一样。在一个对象上拓展另外一个对象和使用`Object.assign`的结果类似。

下述代码表明了一些拓展一个对象的一些属性到另外一个对象上的方法，以及用`Object.assign`该如何使用。你也许也发现了，使用对象拓展更为简洁，如果这个一旦成为标准，它应该被优先使用。

```js
const grocery = { ...details }
// Object.assign({}, details)
const grocery = { type: 'fruit', ...details }
// Object.assign({ type: 'fruit' }, details)
const grocery = { type: 'fruit', ...details, ...fruit }
// Object.assign({ type: 'fruit' }, details, fruit)
const grocery = { type: 'fruit', ...details, color: 'red' }
// Object.assign({ type: 'fruit' }, details, { color: 'red' })
```


与此对应，该提案也包含对象剩余值，就像数组中的剩余模式一样，任何时候我们解构一个对象时我们可以使用对象剩余值。

下面的例子展示了如何利用对象剩余值获取没有被展示对象名的对象。同样需要注意的是对象剩余值需要位于解构的最后面，就像数组的解构模式一样。

```js
const getUnknownProperties = ({ name, type, ...unknown }) =>
  unknown
getUnknownProperties({
  name: 'Carrot',
  type: 'vegetable',
  color: 'orange'
})
// <- { color: 'orange' }
```

我们可以利用类似的方法在变量声明中解构对象，下面的例子中，每一个未被明确结构的属性都将位于`meta`对象中。

```js
const { name, type, ...meta } = {
  name: 'Carrot',
  type: 'vegetable',
  color: 'orange'
}
// <- name = 'Carrot'
// <- type = 'vegetable'
// <- meta = { color: 'orange' }
```

我们将在[Practical Considerations.]()一章再详细讨论对象解构和剩余值。


### 使用`Object.is`对比对象

`Object.is`方法和严格相等运算符`===`略有不同，最重要的地方在于`Object.is(a,b)`和`a===b`是相等的，但是有两个不同的地方，那就是`NaN`以及，`-0`和`0`。

当`NaN`与`NaN`相比较时，严格相等运算符`===`将返回`false`,因为`NaN`和本身也不相等，`Object.is`则在这种情况下返回`true`.

```js
NaN === NaN
// <- false
Object.is(NaN, NaN)
// <- true
```

类似的，使用严格相等运算符比较`0`和`-0`会得到`true`,而使用`Object.is`则会返回`false`.

```js
-0 === +0
// <- true
Object.is(-0, +0)
// <- false
```

这种不同看起来没什么大不了的，但是由于`NaN`的怪癖行为，它的处理一直都很沉重，比如说`typeof NaN`会返回`number`,而它自己和自己又不相等。

### Object.setPrototpyeOf

`Object.setPrototypeOf`的作用就像它的名字描述的那样，它设置它的原型指向另外一个对象。与遗留方法`__proto__`相比，它被认为是设置原型的正常方法。

在ES6之前，我们在ES5中引入了`Object.create`，利用这种方法，我们可以一个对象，这个对象以任何传递给`Object.create`的参数作为原型链。如下所示;

```js
const baseCat = { type: 'cat', legs: 4 }
const cat = Object.create(baseCat)
cat.name = 'Milanesita'
```

不过`Object.create`方法只能在给新创建的对象指定原型，然而，使用`Object.setPrototypeOf`可以用以改变任何已经存在的对象的原型链，如下代码所示：

```js
const baseCat = { type: 'cat', legs: 4 }
const cat = Object.setPrototypeOf(
  { name: 'Milanesita' },
  baseCat
)
```

需要注意的是与`Object.create`比起来，`Object.setPrototypeOf`具有严重的性能问题，因此在你决定使用前还需要仔细考虑。

> #### 对性能问题的说明
> 使用`Object.setPrototypeOf`来改变一个对象的原型是一个昂贵的操作，MDN是这样解释这个问题的：
> 考虑到现代浏览器JavaScript引擎优化属性访问的本质，改变一个对象的原型是一个非常慢的操作，在每一个浏览器和每一个JavaScript引擎中，改变继承在性能方面的影响是微妙而遥远的，时间不仅仅发生在`obj.__proto__`语句中，而且还可能拓展到任何原型被改变的对象。如果你考虑性能的影响，你应该避免改变原型，推荐的做法是，使用需要的原型使用`Object.create()`创建新的对象。
> 


### 装饰器(Decorators)

对于大多数编程语言而言，装饰器不是一个新概念。在现代编程语言中，装饰器模式相当常见，c# 中 有`attributes`,Java中有`annotations`，Python中有`decorators`等等。JavaScript的装饰器提案也正在进行中，目前其处于Stage2。

#### JavaScript 装饰器 基础介绍

JavaScript中的装饰器语法和Python的非常类似。JavaScript的装饰器可以应用于任何对象或者静态声明的属性。诸如对象字面量声明或`class`声明，甚至它们可以吃`get`,`set`存储器，甚至`static`属性。

该提议中表明，装饰器的定义使用`@`之后是一系列的点符号，以及可选的参数列表？？。下面是一些例子：

- `@decorators.frozen`是一个有效的装饰器
- `@decorators.frozen(true)`是一个有效的装饰器
- `@decorators().frozen()`会出现语法错误
- `@decorators['frozen']`会出现语法错误


`class`声明前可以添加0个或多个装饰器，`class`内部也可以：

```js
@inanimate
class Car {}

@expensive
@speed('fast')
class Lamborghini extends Car {}

class View {
  @throttle(200) // reconcile once every 200ms at most
  reconcile() {}
}
```

装饰器的执行类似函数，成员装饰函数获取成员装饰器并返回成员装饰器，成员装饰器和属性装饰器类似，但是呈现不同的形态，下面的代码有一个成员装饰器界面，但是通过装饰器提案定义。一个可选的`finisher`函数被用以接受类构造函数，允许我们被对装饰的对象装修相关操作。

```js
interface MemberDescriptor {
  kind: "Property"
  key: string,
  isStatic: boolean,
  descriptor: PropertyDescriptor,
  extras?: MemberDescriptor[]
  finisher?: (constructor): void;
}
```

下面的例子中，我们定义了一个`readonly`成员描述符，使得被描述的对象不可写，利用对象剩余值和拓展运算符，我们修改了属性描述符为`non-writable`同时保持了其它部分不变。


```js
function readonly({ descriptor, ...rest }) {
  return {
    ...rest,
    descriptor: {
      ...descriptor,
      writable: false
    }
  }
}
```


类装饰器将装饰`ctor`，被描述类的构造函数，`heritage`参数，当装饰器类拓展其它类时包含了父类，`members`数组，里面是被修饰的类的成员描述符列表。

通过在每一个成员描述符上重用`readonly`成员描述符，我们可以实现一个类级别的`readonlyMembers`，如下所示:

```js
function readonlyMembers(ctor, heritage, members) {
  return members.map(member => readonly(member))
}
```

### 堆栈装饰器和对不可变的警告

考虑到不可变形，你可能想要基于已有的装饰器返回一个新的装饰器，而不改变原先的装饰器，尽管这是一种好想法，但是可能会返回意料之外的结果，这是由于它可能会装饰同一种类或同一类成员好多次。

如果一段代码中的任何描述符不考虑它们接收的`descriptor`参数二返回一个全新的装饰器，它们实际上在装饰器返回之前丢失了所有的装饰器。

考虑到提供的装饰器，我们应该小心的来写装饰器。永远都只基于原始的以参数提供的`descriptor `创建一个装饰器。


### 使用示例：C# 中的 Attributes

我是通过一个Ultima Online（注：这是一个有几十年历史的基于终极宇宙的角色扮演类游戏）在很久以前熟悉的C#语言，这个游戏的服务器使用的是C#代码编写的RunUO。RunUO是我用过的最美待代码库之一了。

他们将服务器软件分发为可执行文件和一系列cs文件。runuo会在运行时编译这些`.cs`文件，并动态的混合他们为程序。结果是你不再需要使用Visual Studio IED了，也不需要任何其它的编辑`.cs`脚本之外的编程知识了。这使得RunOS对于新开发者是非常易学的。

RunOS非常依赖于反映reflection，为了让不熟悉编程的人员但仍然对改变游戏的一些细节感兴趣自定义，它的开发者投入了巨大的精力。比如说，龙的呼吸火焰造成多少伤害，或发射火球的频率。良好的开发体验使他们的主要哲学，你可以通过复制一个怪物文件，改变它来继承龙类，重写一些属性来改变它的颜色，它的伤害输出等等，来创建一种新的龙。

正如他们让创建新怪物或NPC非常容易，他们还依靠反射来为游戏中的管理员提供功能。管理员可以在游戏内运行命令，通过简单的在物品或怪物上点击来可视化或者改变一些属性。

![Modifying properties for a RunUO item in-game from the Ultima Online client](https://ponyfoo.com/books/practical-modern-javascript/img/pmjs_0301.png)

并非一个类中的所有属性在游戏中都可以修改，一些属性只能供内部使用，或者在运行时不可修改。RunUO提供了一个名为`CommandPropertyAttribute`的装饰器，这个装饰器定义了游戏中可以被修改的属性，而且也让你指明了属性的可读写等级。在整个RunUO代码库中，这个装饰器被广泛的使用。

控制用户角色如何工作的类`PlayerMobile`是一个观察这些特性的好地方，`PlayerMobile`拥有一些在游戏中管理者可接触到的属性，这里有一系列的`setter`和`getter`,但是只有第一个拥有`CommandProperty`属性，这使得游戏操作者在游戏中可修改这些属性。

```c#
[CommandProperty(AccessLevel.GameMaster)]
public int Profession
{
  get{ return m_Profession }
  set{ m_Profession = value }
}

public int StepsTaken
{
  get{ return m_StepsTaken }
  set{ m_StepsTaken = value }
}
```

C# 的属性和JavaScript的装饰器在一个有趣的不同地方在于，C#中的映射允许我们拖出拥有`getCustomAttributes`的对象的所有自定义属性。RunUO正是使用了这种特性来在拉去每个应该在游戏中可用的属性的信息，这时候会出现一个对话框使得管理者在游戏中查看或修改对象的属性。

### 在JavaScript的标记属性

在JavaScript中并不存在类似的东西，不存在于已有的草案中，至少不能获取属性的自定义特征。这意味着，JavaScript是一个高动态的语言，创建这类的标签并非难事。使用命令行属性装饰`Dog`类并不会和C# 中的 RunUO差别太多。

```js
class Dog {
  @commandProperty('game-master')
  name;
}
```

和C#中的实现机制相比，在JavaScript中实现`commandProperty`函数会稍微复杂一点点，考虑到JavaScript中的装饰器没有反映，我们可以使用一个运行时范围的符号来围绕给定类来保持一个命令属性数组。

```js
function commandProperty(writeLevel, readLevel = writeLevel) {
  return ({ key, ...rest }) => ({
    key,
    ...rest,
    finisher(ctor) {
      const symbol = Symbol.for('commandProperties')
      const commandPropertyDescriptor = {
        key,
        readLevel,
        writeLevel
      }
      if (!ctor[symbol]) {
        ctor[symbol] = []
      }
      ctor[symbol].push(commandPropertyDescriptor)
    }
  })
}
```

`Dog`类因此可以拥有尽可能多的我们认为必要的命令行属性，每一个都将被列在一个符号属性后。为了找到所有给定类的命令属性，我们只需要使用下面这个函数，它从符号属性中接受一组命令属性，并设置其默认值为`[]`，我们同样保存了原始数组的复制数组用以防止用户由于偶然而改变了它。

```js
function getCommandProperties(ctor) {
  const symbol = Symbol.for('commandProperties')
  const properties = ctor[symbol] || []
  return [...properties]
}
getCommandProperties(Dog)
// <- [{ key: 'name', readLevel: 'game-master',
// writeLevel: 'game-master' }]
```

然后，我们可以迭代已知的安全命令属性，并在运行时通过简单的UI呈现修改这些属性的方法，而不是维持可被修改的长列表，也不需要依靠某种试探性的方法来不时地打破，或者使用某种限制性的命名约定。相比这些，装饰器在我们想要对一个属性上标志特殊的属性时是最简洁有效的。

下一章，我们将一起看看ES6提供的关于对象迭代的一些更新，然后我们也将讨论一下如何利用`promises`和`generators`来控制异步。









